<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>IA Skirmish — CC Effect Editor</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: system-ui, sans-serif; padding: 20px; background: #1e1e1e; color: #eee; max-width: 960px; }
    h1 { font-size: 1.3rem; margin-bottom: 8px; }
    .hint { font-size: 12px; color: #999; margin-bottom: 16px; }
    .main { display: flex; gap: 24px; align-items: flex-start; flex-wrap: wrap; }
    .card-img-wrap { flex-shrink: 0; width: 180px; min-height: 250px; background: #2d2d2d; border-radius: 8px; display: flex; align-items: center; justify-content: center; overflow: hidden; }
    .card-img-wrap img { max-width: 100%; max-height: 280px; object-fit: contain; }
    .card-img-wrap .placeholder { color: #666; font-size: 13px; text-align: center; padding: 16px; }
    .form-wrap { flex: 1; min-width: 280px; }
    label { display: block; margin-top: 12px; margin-bottom: 4px; font-weight: 500; }
    select, input, textarea { width: 100%; padding: 8px 12px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; font-size: 14px; }
    textarea { min-height: 80px; font-family: inherit; resize: vertical; }
    .row { display: flex; gap: 12px; margin-top: 16px; flex-wrap: wrap; }
    button { padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; }
    button.primary { background: #0d6efd; color: #fff; }
    button.primary:hover { background: #0b5ed7; }
    button.export { background: #198754; color: #fff; }
    button.export:hover { background: #157347; }
    button.verified { background: #dc3545; color: #fff; }
    button.verified:hover { background: #bb2d3b; }
    .entries { margin-top: 24px; }
    .entries h2 { font-size: 1rem; margin-bottom: 8px; }
    .entry { padding: 8px 12px; margin-bottom: 6px; background: #2d2d2d; border-radius: 4px; font-size: 13px; display: flex; justify-content: space-between; align-items: center; }
    .entry span { color: #aaa; }
    .entry button { padding: 4px 10px; font-size: 12px; background: #dc3545; }
    .entry button:hover { background: #bb2d3b; }
  </style>
</head>
<body>
  <h1>IA Skirmish — Command Card Effect Editor</h1>
  <p class="hint">Run <code>npm run cc-review</code> and open this page at <code>http://localhost:3456/scripts/cc-effect-editor.html</code>. Cards load from cc-effects.json. Correct any fields as needed, then click <strong>VERIFIED</strong> to mark a card 100% play-ready — verified cards are removed from the list. Progress = list shrinking to 0.</p>

  <div class="main">
    <div class="card-img-wrap" id="cardImgWrap">
      <div class="placeholder" id="cardImgPlaceholder">Select a card</div>
      <img id="cardImg" alt="" style="display:none">
    </div>
    <div class="form-wrap">
  <label>Card name</label>
  <select id="cardSelect">
    <option value="">— Select or type below —</option>
  </select>
  <input type="text" id="cardName" placeholder="Or type card name manually">

  <label>Cost (bottom left of card, 0–3)</label>
  <input type="number" id="cost" min="0" max="5" placeholder="e.g. 1">

  <label>Playable by (center of card)</label>
  <input type="text" id="playableBy" placeholder="e.g. Any Figure, Hunter, Boba Fett">

  <label>Timing</label>
  <p class="hint" style="margin: 2px 0 4px 0;">Implementation note: only check a CC’s timing when it’s in hand; only check DC-correlated triggers when that DC is on the field (e.g. don’t check Agent Blaise’s card if he’s not in the game / his CC isn’t in hand).</p>
  <select id="timing">
    <option value="">—</option>
    <option value="atStartOfActivationOfHostileFigureInYourLineOfSight">At the start of an activation of a hostile figure in your line of sight</option>
    <option value="afterActivationResolves">After an activation resolves</option>
    <option value="afterAttack">After attack</option>
    <option value="afterAttackDice">After attack dice are rolled</option>
    <option value="afterAttackTargetingYouResolved">After an attack targeting you is resolved</option>
    <option value="afterDamage">After damage is applied</option>
    <option value="afterHostileFigureSuffersDamage">After a hostile figure suffers Damage</option>
    <option value="afterInteract">After Interact (during activation)</option>
    <option value="afterLastFigureInNonUniqueGroupDefeated">After the last figure in a non-unique group is defeated</option>
    <option value="afterSpecial">After resolving a Special (during activation)</option>
    <option value="afterSpecialOrInteract">After Special or Interact (during activation)</option>
    <option value="afterUniqueHostileDefeated">After a unique hostile figure is defeated</option>
    <option value="afterYouMove">After you move</option>
    <option value="afterYouResolveAttackTargetingFigure">After you resolve an attack targeting a figure</option>
    <option value="afterYouResolveAttackThatDidNotMissDueToAccuracy">After you resolve an attack that did not miss due to accuracy</option>
    <option value="afterYouResolveGroupsActivation">After you resolve a group's activation</option>
    <option value="afterYouResolveInterrogate">After you resolve "Interrogate"</option>
    <option value="beforeAttack">Before attack</option>
    <option value="beforeAttackDice">Before attack dice are rolled</option>
    <option value="beforeDeclaringRangedAttack">Before declaring a Ranged attack</option>
    <option value="beforeYouDeclareAttack">Before you declare an attack</option>
    <option value="beforeYouPerformInteract">Before you perform an Interact</option>
    <option value="doubleActionSpecial">Double Action special</option>
    <option value="duringActivation">During activation</option>
    <option value="duringAttack">During attack</option>
    <option value="endOfActivation">End of activation</option>
    <option value="endOfRound">End of round</option>
    <option value="endOfStatusPhase">End of Status Phase</option>
    <option value="other">Other</option>
    <option value="specialAction">Special Action</option>
    <option value="startOfActivation">Start of activation</option>
    <option value="startOfRound">Start of round</option>
    <option value="startOfStatusPhase">Start of Status Phase</option>
    <option value="statusPhase">Status Phase</option>
    <option value="whenAnotherFriendlyTrooperDeclaresAttackTargetingInYourLineOfSight">When another friendly TROOPER declares an attack targeting a target in your line of sight</option>
    <option value="whenAttackDeclaredOnAdjacentFriendly">When an attack targeting an adjacent friendly figure is declared</option>
    <option value="whenAttackDeclaredOnYou">When an attack targeting you is declared</option>
    <option value="whenAttackDeclaredTargetingFriendlySmallFigureCost10OrLessWithin3Spaces">When an attack is declared targeting another friendly SMALL figure with a figure cost of 10 or less within 3 spaces</option>
    <option value="whenCommandCardPlayed">When a command card is played</option>
    <option value="whenDefeated">When defeated</option>
    <option value="whenDiceRolled">When dice are rolled</option>
    <option value="whenEnemyFigureActivates">When an enemy figure activates</option>
    <option value="whenEnemyFigureEndsActivation">When an enemy figure ends its activation</option>
    <option value="whenFigureWouldSufferDamage">When a figure would suffer damage</option>
    <option value="whenFriendlyFigureWithin2SpacesSuffers3PlusDamage">When another friendly figure within 2 spaces suffers 3 or more Damage</option>
    <option value="whenFriendlyFigureWithin3SpacesWouldBeDefeated">When a friendly figure within 3 spaces would be defeated</option>
    <option value="whenHostileFigureDefeatedNotYourActivation">When a hostile figure is defeated and it is not your activation</option>
    <option value="whenHostileFigureEntersSpaceWithin3Spaces">When a hostile figure enters a space within 3 spaces of you</option>
    <option value="whenHostileFigureEntersAdjacentSpace">When a hostile figure enters a space adjacent to you</option>
    <option value="whenHostileFigureExitsAdjacentSpace">When a hostile figure exits an adjacent space</option>
    <option value="whenHostileFigureInYourLineOfSightAttacking">When a hostile figure in your line of sight is attacking</option>
    <option value="whenHostileFigureWithin3SpacesDefeated">When a hostile figure within 3 spaces is defeated</option>
    <option value="whenOneOfYourFiguresDefeated">When one of your figures is defeated</option>
    <option value="whenYouDeclareAttack">When you declare an attack</option>
    <option value="whenYouDeclareAttackTargetingHostileWithHighestFigureCost">When you declare an attack targeting a hostile figure with the highest figure cost of all hostile figures on the map</option>
    <option value="whenYouDeclareCloseQuarters">When you declare "Close Quarters"</option>
    <option value="whenYouDeclareLightsaberThrow">When you declare "Lightsaber Throw"</option>
    <option value="whenYouDefeatFigure">When you defeat a figure</option>
    <option value="whenYouEndMovementInSpacesWithOtherFigures">When you end your movement in spaces that contain one or more other figures</option>
    <option value="whenYouHaveSufferedDamageEqualToYourHealth">When you have suffered Damage equal to your Health</option>
    <option value="whenYouMove">When you move</option>
    <option value="whenYouPerformAttack">When you perform an attack</option>
    <option value="whenYouPerformInteract">When you perform an Interact</option>
    <option value="whenYouPerformRapidFire">When you perform "Rapid Fire"</option>
    <option value="whenYouPerformSpecial">When you perform a Special</option>
    <option value="whenYouPlayCommandCard">When you play a command card</option>
    <option value="whenYouRestoreFigure">When you restore a figure</option>
    <option value="whenYouRevealCommandCard">When you reveal a command card</option>
    <option value="whenYouWouldBeDefeated">When you would be defeated</option>
    <option value="whenYouWouldSufferDamage">When you would suffer damage</option>
    <option value="useWhenYouUseGambit">When you use "Gambit"</option>
    <option value="whileAttackingAfterAttackDiceRolledOrRerolled">While attacking, after attack dice are rolled (or rerolled)</option>
    <option value="whenFigureWithin3SpacesDefending">While a figure within 3 spaces is defending</option>
    <option value="whileAdjacentFriendlyFigureDefending">While an adjacent friendly figure is defending</option>
    <option value="whileDefending">While defending</option>
  </select>

  <label>Effect (card text)</label>
  <p class="hint" style="margin: 4px 0 6px 0;">Use full card text. Put traits in ALL CAPS (e.g. WOOKIES, Hunter, Droid, Rebel) so they stand out.</p>
  <textarea id="effect" placeholder="Paste or type the card effect"></textarea>

  <div class="row">
    <button id="addBtn" class="primary">Add / Update</button>
    <button id="verifyBtn" class="verified">VERIFIED</button>
    <button id="saveBtn" class="export">Save to data/cc-effects.json (e.g. after Remove)</button>
  </div>
    </div>
  </div>

  <div class="entries">
    <h2>Unverified: <span id="count">0</span> — Verified: <span id="verifiedCount">0</span> — Total: <span id="totalCount">0</span> — Shrink unverified to 0 by clicking VERIFIED</h2>
    <p id="debugHint" class="hint" style="display:none; margin-top:4px;"></p>
    <div id="list"></div>
  </div>

  <script src="cc-names.js"></script>
  <script>
    const cardSelect = document.getElementById('cardSelect');
    const cardName = document.getElementById('cardName');
    const cost = document.getElementById('cost');
    const playableBy = document.getElementById('playableBy');
    const timing = document.getElementById('timing');
    const effect = document.getElementById('effect');
    const addBtn = document.getElementById('addBtn');
    const listEl = document.getElementById('list');
    const countEl = document.getElementById('count');
    const verifiedCountEl = document.getElementById('verifiedCount');
    const totalCountEl = document.getElementById('totalCount');

    const names = typeof CC_NAMES !== 'undefined' ? CC_NAMES : [];
    const VERIFIED_KEY = 'cc-verified';
    let verified = new Set(JSON.parse(localStorage.getItem(VERIFIED_KEY) || '[]'));

    function saveVerified() {
      localStorage.setItem(VERIFIED_KEY, JSON.stringify([...verified]));
      saveVerifiedToFile(false);
    }

    async function saveVerifiedToFile(silent = false) {
      try {
        const r = await fetch('/api/save-cc-verified', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ verified: [...verified] }),
        });
        const text = await r.text();
        let j;
        try { j = JSON.parse(text); } catch { j = {}; }
        if (r.ok && j.ok) return;
        if (!silent) alert('Save verified failed: ' + (j.error || r.status + ' ' + text.slice(0, 80)));
      } catch (e) {
        if (!silent) alert('Save verified failed: ' + e.message + '. Restart npm run cc-review?');
      }
    }

    const TRAIT_PLACEHOLDER_NAMES = new Set(['All CCs', 'Command Cards', 'Brawler', 'Creature', 'Droid', 'Force User', 'Guardian', 'Heavy Weapon', 'Hunter', 'Leader', 'Smuggler', 'Spy', 'Technician', 'Trooper', 'Vehicle', 'Wookiee']);
    function isPlaceholderCard(name, _data) {
      return TRAIT_PLACEHOLDER_NAMES.has(name);
    }
    function getUnverifiedCards() {
      const source = (names && names.length > 0) ? names : Object.keys(cards);
      return source
        .filter((n) => !verified.has(n) && !isPlaceholderCard(n, cards[n]))
        .sort((a, b) => a.localeCompare(b));
    }

    function updateCardSelect() {
      const unverified = getUnverifiedCards();
      cardSelect.innerHTML = '<option value="">— Select or type below —</option>';
      unverified.forEach((n) => {
        const opt = document.createElement('option');
        opt.value = n;
        opt.textContent = n;
        cardSelect.appendChild(opt);
      });
    }

    function updateCardImage() {
      const name = (cardName.value || cardSelect.value || '').trim();
      const img = document.getElementById('cardImg');
      const placeholder = document.getElementById('cardImgPlaceholder');
      if (!name) {
        img.style.display = 'none';
        placeholder.style.display = 'block';
        placeholder.textContent = 'Select a card';
        return;
      }
      const apiUrl = '/api/cc-image/' + encodeURIComponent(name);
      img.src = apiUrl;
      img.alt = name;
      img.style.display = 'block';
      img.onload = () => { placeholder.style.display = 'none'; };
      img.onerror = () => {
        img.style.display = 'none';
        placeholder.style.display = 'block';
        placeholder.textContent = 'No image (run npm run cc-review)';
      };
      placeholder.style.display = 'none';
    }

    function onCardChange() {
      const name = (cardName.value || cardSelect.value || '').trim();
      updateCardImage();
      if (name && cards[name]) {
        cost.value = cards[name].cost != null ? cards[name].cost : '';
        playableBy.value = cards[name].playableBy || '';
        timing.value = cards[name].timing || '';
        effect.value = cards[name].effect || '';
      } else {
        cost.value = '';
        playableBy.value = '';
        timing.value = '';
        effect.value = '';
      }
    }

    cardSelect.addEventListener('change', () => {
      cardName.value = cardSelect.value || '';
      onCardChange();
    });
    cardName.addEventListener('input', () => {
      const v = cardName.value.trim();
      if (names.includes(v) && !cards[v]) cardSelect.value = v;
      else cardSelect.value = '';
      onCardChange();
    });

    timing.addEventListener('change', () => {
      if (!effect.value.trim()) {
        const opt = timing.options[timing.selectedIndex];
        const label = opt && opt.value ? opt.textContent : '';
        if (label) effect.value = 'Use ' + label.charAt(0).toLowerCase() + label.slice(1);
      }
    });

    let cards = {};

    addBtn.addEventListener('click', () => {
      const name = (cardName.value || cardSelect.value || '').trim();
      if (!name) { alert('Enter a card name'); return; }
      const costVal = cost.value.trim();
      cards[name] = {
        cost: costVal === '' ? null : Math.max(0, parseInt(costVal, 10) || 0),
        playableBy: playableBy.value.trim() || 'Any Figure',
        timing: timing.value || 'other',
        effect: effect.value.trim() || '',
        effectType: 'manual',
      };
      render();
      const nextOpt = cardSelect.options[1];
      if (nextOpt && nextOpt.value) {
        cardSelect.value = nextOpt.value;
        cardName.value = nextOpt.value;
        onCardChange();
      } else {
        cardSelect.value = '';
        cardName.value = '';
        onCardChange();
      }
      saveToFile(true);
    });

    document.getElementById('verifyBtn').addEventListener('click', () => {
      const name = (cardName.value || cardSelect.value || '').trim();
      if (!name) { alert('Select a card to verify'); return; }
      const costVal = cost.value.trim();
      cards[name] = {
        cost: costVal === '' ? null : Math.max(0, parseInt(costVal, 10) || 0),
        playableBy: playableBy.value.trim() || 'Any Figure',
        timing: timing.value || 'other',
        effect: effect.value.trim() || '',
        effectType: 'manual',
      };
      verified.add(name);
      saveVerified();
      saveToFile(true);
      render();
      const nextOpt = cardSelect.options[1];
      if (nextOpt && nextOpt.value) {
        cardSelect.value = nextOpt.value;
        cardName.value = nextOpt.value;
        onCardChange();
      } else {
        cardSelect.value = '';
        cardName.value = '';
        onCardChange();
      }
    });

    const TOTAL_CANONICAL_CC = names.length;
    function getVerifiedCount() {
      return names.filter((n) => verified.has(n)).length;
    }
    function getUnverifiedCount() {
      return getUnverifiedCards().length;
    }
    const debugHintEl = document.getElementById('debugHint');
    function render() {
      updateCardSelect();
      listEl.innerHTML = '';
      const unverified = getUnverifiedCards();
      countEl.textContent = getUnverifiedCount();
      verifiedCountEl.textContent = getVerifiedCount();
      totalCountEl.textContent = TOTAL_CANONICAL_CC;
      if (debugHintEl) {
        if (names.length === 0) {
          debugHintEl.textContent = 'Debug: CC_NAMES not loaded (names=0). Check that cc-names.js loads from /scripts/cc-names.js.';
          debugHintEl.style.display = 'block';
        } else {
          debugHintEl.style.display = 'none';
        }
      }
      unverified.forEach((name) => {
        const data = cards[name] || {};
        const div = document.createElement('div');
        div.className = 'entry';
        const costStr = data.cost != null ? `[${data.cost}] ` : '';
        div.innerHTML = `<strong>${costStr}${name}</strong> <span>${(data.playableBy || '—')} • ${(data.timing || '—')}</span> <button data-name="${name.replace(/"/g, '&quot;')}">Remove</button>`;
        div.querySelector('button').addEventListener('click', (e) => {
          e.stopPropagation();
          delete cards[name];
          render();
        });
        div.style.cursor = 'pointer';
        div.addEventListener('click', (e) => {
          if (e.target.tagName === 'BUTTON') return;
          cardSelect.value = name;
          cardName.value = name;
          onCardChange();
        });
        listEl.appendChild(div);
      });
    }

    async function saveToFile(silent = false) {
      const out = { source: 'CC Effect Editor', cards };
      try {
        const r = await fetch('/api/save-cc-effects', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(out),
        });
        const j = await r.json();
        if (j.ok) { if (!silent) alert('Saved to data/cc-effects.json'); }
        else alert('Save failed: ' + (j.error || r.status));
      } catch (e) {
        alert('Save failed: ' + e.message + '. Run npm run cc-review first.');
      }
    }

    document.getElementById('saveBtn').addEventListener('click', () => saveToFile(false));

    const loadInput = document.createElement('input');
    loadInput.type = 'file';
    loadInput.accept = '.json';
    loadInput.style.display = 'none';
    loadInput.addEventListener('change', () => {
      const f = loadInput.files[0];
      if (!f) return;
      const r = new FileReader();
      r.onload = () => {
        try {
          const d = JSON.parse(r.result);
          if (d.cards) {
            cards = d.cards;
            render();
            const current = (cardName.value || cardSelect.value || '').trim();
            if (current && cards[current]) {
              const nextOpt = cardSelect.options[1];
              if (nextOpt && nextOpt.value) {
                cardSelect.value = nextOpt.value;
                cardName.value = nextOpt.value;
                onCardChange();
              } else {
                cardSelect.value = '';
                cardName.value = '';
                onCardChange();
              }
            }
          }
        } catch (e) { alert('Invalid JSON'); }
      };
      r.readAsText(f);
    });
    document.body.appendChild(loadInput);
    const loadBtn = document.createElement('button');
    loadBtn.textContent = 'Load from file';
    loadBtn.onclick = () => loadInput.click();
    document.querySelector('.row').appendChild(loadBtn);

    const loadExistingBtn = document.createElement('button');
    loadExistingBtn.textContent = 'Load existing (data/cc-effects.json)';
    loadExistingBtn.onclick = async () => {
      try {
        const r = await fetch('/data/cc-effects.json');
        if (!r.ok) throw new Error(r.status);
        const d = await r.json();
        if (d.cards) {
          cards = d.cards;
          render();
          const current = (cardName.value || cardSelect.value || '').trim();
          if (current && cards[current]) {
            const nextOpt = cardSelect.options[1];
            if (nextOpt && nextOpt.value) {
              cardSelect.value = nextOpt.value;
              cardName.value = nextOpt.value;
              onCardChange();
            } else {
              cardSelect.value = '';
              cardName.value = '';
              onCardChange();
            }
          }
          alert('Loaded ' + Object.keys(cards).length + ' entries');
        }
      } catch (e) {
        alert('Load failed: ' + e.message + '. Run npm run cc-review first.');
      }
    };
    document.querySelector('.row').appendChild(loadExistingBtn);

    function selectFirstRemainingCard() {
      const firstOpt = cardSelect.options[1];
      if (firstOpt && firstOpt.value) {
        cardSelect.value = firstOpt.value;
        cardName.value = firstOpt.value;
        onCardChange();
      } else {
        cardSelect.value = '';
        cardName.value = '';
        onCardChange();
      }
    }

    render();
    (async () => {
      try {
        const r = await fetch('/data/cc-effects.json');
        if (r.ok) {
          const d = await r.json();
          if (d.cards && Object.keys(d.cards).length > 0) {
            cards = d.cards;
          }
        }
      } catch (_) {}
      try {
        const rv = await fetch('/data/cc-verified.json');
        if (rv.ok) {
          const dv = await rv.json();
          if (dv.verified && Array.isArray(dv.verified)) {
            verified = new Set(dv.verified);
            saveVerified(); // sync to localStorage
          }
        }
      } catch (_) {}
      render();
      selectFirstRemainingCard();
    })();
  </script>
</body>
</html>
