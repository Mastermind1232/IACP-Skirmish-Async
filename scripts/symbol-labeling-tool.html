<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Symbol Labeling Tool — IA Skirmish</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: system-ui, sans-serif; padding: 16px; background: #1e1e1e; color: #eee; max-width: 1000px; }
    h1 { font-size: 1.2rem; margin-bottom: 8px; }
    .tabs { display: flex; gap: 4px; margin-bottom: 16px; }
    .tabs button { padding: 8px 16px; background: #333; color: #ccc; border: 1px solid #555; border-radius: 6px; cursor: pointer; }
    .tabs button.active { background: #0d6efd; color: #fff; border-color: #0d6efd; }
    .panel { display: none; }
    .panel.active { display: block; }
    .hint { font-size: 12px; color: #999; margin-bottom: 12px; }
    .asset-section { margin-bottom: 20px; }
    .asset-section h3 { font-size: 0.95rem; margin-bottom: 8px; }
    .asset-row { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; padding: 6px 0; border-bottom: 1px solid #333; }
    .asset-row img { width: 40px; height: 40px; object-fit: contain; background: #2d2d2d; border-radius: 4px; }
    .asset-row input[type="text"] { width: 140px; padding: 6px 10px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; }
    .asset-row select { padding: 6px 10px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; min-width: 120px; }
    .card-picker { margin-bottom: 16px; }
    .card-picker select { padding: 8px 12px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; min-width: 260px; }
    .card-canvas-wrap { position: relative; display: inline-block; max-width: 100%; margin: 12px 0; }
    .card-canvas-wrap img { max-width: 320px; height: auto; display: block; }
    .card-canvas-wrap canvas { position: absolute; left: 0; top: 0; pointer-events: none; }
    .card-canvas-wrap .overlay { position: absolute; left: 0; top: 0; right: 0; bottom: 0; cursor: crosshair; }
    .crop-form { margin-top: 12px; display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .crop-form input[type="text"] { padding: 8px 12px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; width: 160px; }
    .crop-form select { padding: 8px 12px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; }
    button.primary { padding: 8px 16px; background: #0d6efd; color: #fff; border: none; border-radius: 6px; cursor: pointer; }
    button.primary:hover { background: #0b5ed7; }
    .status { font-size: 12px; margin-left: 12px; }
    .status.ok { color: #198754; }
    .status.err { color: #dc3545; }
    .symbol-list { margin-top: 24px; padding-top: 16px; border-top: 1px solid #444; }
    .symbol-list h3 { font-size: 0.95rem; margin-bottom: 8px; }
    .glossary-list { list-style: none; padding: 0; margin: 0; max-height: 320px; overflow-y: auto; }
    .glossary-list li { display: flex; align-items: center; gap: 10px; padding: 6px 8px; margin-bottom: 4px; background: #2d2d2d; border-radius: 4px; font-size: 13px; }
    .glossary-list li img { width: 28px; height: 28px; object-fit: contain; background: #1e1e1e; border-radius: 3px; flex-shrink: 0; }
    .glossary-list li .line-text { flex: 1; min-width: 0; }
    .glossary-list li .del { font-size: 11px; color: #999; cursor: pointer; flex-shrink: 0; }
    .glossary-list li .del:hover { color: #dc3545; }
    .symbol-card { display: inline-flex; flex-direction: column; align-items: center; gap: 4px; background: #2d2d2d; padding: 8px; border-radius: 6px; margin: 4px; width: 100px; vertical-align: top; }
    .symbol-card img { width: 40px; height: 40px; object-fit: contain; }
    .symbol-card .label { font-size: 11px; text-align: center; word-break: break-word; }
    .symbol-card .del { font-size: 10px; color: #999; cursor: pointer; }
    .symbol-card .del:hover { color: #dc3545; }
    .dice-face-layout { display: flex; gap: 24px; align-items: flex-start; flex-wrap: wrap; }
    .dice-face-wrap { position: relative; display: inline-block; }
    .dice-face-wrap { text-align: center; margin: 16px 0; }
    .dice-face-wrap img { width: 50px; max-width: 100%; height: auto; display: block; margin: 0 auto; image-rendering: auto; }
    .dice-progress { font-size: 14px; color: #aaa; margin-bottom: 8px; }
    .dice-estimate { font-size: 12px; color: #888; margin-bottom: 8px; }
    .dice-outcome-row { margin: 16px 0; display: flex; align-items: center; gap: 12px; flex-wrap: wrap; justify-content: center; }
    .dice-outcome-row input { padding: 10px 14px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; min-width: 300px; font-size: 14px; }
    .dice-nav { display: flex; gap: 12px; align-items: center; justify-content: center; flex-wrap: wrap; margin-top: 12px; }
    .dice-remaining { margin-top: 24px; padding-top: 16px; border-top: 1px solid #333; }
    .dice-remaining h4 { margin: 0 0 8px 0; font-size: 14px; color: #ccc; }
    .dice-remaining-list { display: flex; flex-direction: column; flex-wrap: wrap; max-height: 320px; overflow-y: auto; gap: 4px; }
    .dice-remaining-list .entry { display: block; padding: 6px 10px; font-size: 13px; background: #2d2d2d; border-radius: 4px; cursor: pointer; color: #ccc; }
    .dice-remaining-list .entry:hover { background: #3d3d3d; color: #fff; }
    .dice-saved-list { margin-top: 12px; max-height: 160px; overflow-y: auto; }
    .dice-saved-list h4 { margin: 0 0 6px 0; font-size: 12px; color: #999; }
    .dice-saved-list ul { list-style: none; padding: 0; margin: 0; }
    .dice-saved-list li { padding: 4px 8px; font-size: 13px; color: #ccc; }
    .server-warning { background: #3d2a1a; border: 1px solid #8b5a00; color: #ffc; padding: 12px 16px; margin-bottom: 16px; border-radius: 6px; font-size: 13px; }
    .server-warning code { background: #2d2d2d; padding: 2px 6px; border-radius: 4px; }
    .server-warning a { color: #8cf; }
  </style>
</head>
<body>
  <div id="serverWarning" class="server-warning" style="display: none;">
    <strong>Save won’t work.</strong> You must use the <strong>cc-review</strong> server, not a plain static server.
    In the project folder run: <code>npm run cc-review</code>, then open:
    <a href="http://localhost:3456/scripts/symbol-labeling-tool.html" target="_blank" rel="noopener">http://localhost:3456/scripts/symbol-labeling-tool.html</a>
  </div>
  <h1>Symbol Labeling Tool</h1>
  <div class="tabs">
    <button type="button" id="tabAssets" class="active">1. Label existing files</button>
    <button type="button" id="tabCards">2. Label symbol on card</button>
    <button type="button" id="tabDice">3. Dice faces</button>
  </div>

  <div id="panelAssets" class="panel active">
    <p class="hint">Confirm or edit the label for each symbol file. Then click Save to glossary.</p>
    <div id="assetList"></div>
    <div>
      <button type="button" id="saveAssetsBtn" class="primary">Save</button>
      <span id="assetsStatus" class="status"></span>
    </div>
  </div>

  <div id="panelCards" class="panel">
    <p class="hint">Pick a card, draw a box around one symbol, then enter the label and add.</p>
    <div class="card-picker">
      <select id="cardSelect"><option value="">— Select a card —</option></select>
    </div>
    <div id="cardImageWrap" class="card-canvas-wrap" style="display:none">
      <img id="cardImage" alt="">
      <canvas id="boxCanvas"></canvas>
      <div id="overlay" class="overlay"></div>
    </div>
    <div id="cropForm" class="crop-form" style="display:none">
      <input type="text" id="cropLabel" placeholder="Label (e.g. Pierce 2)">
      <select id="cropCategory">
        <option value="surge">Surge</option>
        <option value="attack-die">Attack die</option>
        <option value="defense-die">Defense die</option>
        <option value="keyword">Keyword</option>
        <option value="passive">Passive</option>
        <option value="other">Other</option>
      </select>
      <button type="button" id="addCropBtn" class="primary">Add symbol to glossary</button>
    </div>
    <div style="margin-top:12px">
      <button type="button" id="saveGlossaryBtn" class="primary">Save</button>
      <span id="cropStatus" class="status"></span>
    </div>
  </div>

  <div id="panelDice" class="panel">
    <p class="hint">We show one dice face at a time with our estimate. Verify as-is or edit the field, then click Verify to save and go to the next.</p>
    <div id="diceProgress" class="dice-progress"></div>
    <div id="diceEstimate" class="dice-estimate"></div>
    <div id="diceFaceWrap" class="dice-face-wrap">
      <img id="diceFaceImage" alt="">
    </div>
    <div class="dice-outcome-row">
      <label style="flex-shrink:0">This face indicates:</label>
      <input type="text" id="diceOutcomeInput" placeholder="e.g. +1 Hit, +1 Block">
    </div>
    <div class="dice-nav">
      <button type="button" id="dicePrevBtn" class="primary">Previous</button>
      <button type="button" id="diceUpdateBtn" class="primary">Update</button>
      <button type="button" id="diceVerifyBtn" class="primary">Verify &amp; Next</button>
      <span id="diceFaceStatus" class="status"></span>
    </div>
    <div class="dice-remaining">
      <h4>Remaining to verify (<span id="diceRemainingCount">36</span>)</h4>
      <div id="diceRemainingList" class="dice-remaining-list"></div>
    </div>
    <div class="dice-saved-list">
      <h4>Verified outcomes</h4>
      <ul id="diceSavedList"></ul>
    </div>
  </div>

  <div class="symbol-list">
    <h3>Glossary (<span id="glossaryCount">0</span>)</h3>
    <div id="glossaryPreview"></div>
  </div>

  <script>
(function () {
  const serverWarning = document.getElementById('serverWarning');
  fetch('/api/cc-review-server').then(function (r) { if (!r.ok && serverWarning) serverWarning.style.display = 'block'; }).catch(function () { if (serverWarning) serverWarning.style.display = 'block'; });

  const tabAssets = document.getElementById('tabAssets');
  const tabCards = document.getElementById('tabCards');
  const panelAssets = document.getElementById('panelAssets');
  const panelCards = document.getElementById('panelCards');
  const assetList = document.getElementById('assetList');
  const saveAssetsBtn = document.getElementById('saveAssetsBtn');
  const assetsStatus = document.getElementById('assetsStatus');
  const cardSelect = document.getElementById('cardSelect');
  const cardImageWrap = document.getElementById('cardImageWrap');
  const cardImage = document.getElementById('cardImage');
  const boxCanvas = document.getElementById('boxCanvas');
  const overlay = document.getElementById('overlay');
  const cropForm = document.getElementById('cropForm');
  const cropLabel = document.getElementById('cropLabel');
  const cropCategory = document.getElementById('cropCategory');
  const addCropBtn = document.getElementById('addCropBtn');
  const saveGlossaryBtn = document.getElementById('saveGlossaryBtn');
  const cropStatus = document.getElementById('cropStatus');
  const glossaryCount = document.getElementById('glossaryCount');
  const glossaryPreview = document.getElementById('glossaryPreview');

  let glossary = { symbols: [] };
  let assetRows = [];
  let cardList = [];
  let drag = null;
  let cropRect = null;
  let diceData = { attack: {}, defense: {} };
  let diceOutcomes = {};

  const tabDice = document.getElementById('tabDice');
  const panelDice = document.getElementById('panelDice');
  const diceProgress = document.getElementById('diceProgress');
  const diceEstimate = document.getElementById('diceEstimate');
  const diceFaceWrap = document.getElementById('diceFaceWrap');
  const diceFaceImage = document.getElementById('diceFaceImage');
  const diceOutcomeInput = document.getElementById('diceOutcomeInput');
  const dicePrevBtn = document.getElementById('dicePrevBtn');
  const diceUpdateBtn = document.getElementById('diceUpdateBtn');
  const diceVerifyBtn = document.getElementById('diceVerifyBtn');
  const diceFaceStatus = document.getElementById('diceFaceStatus');
  const diceRemainingCount = document.getElementById('diceRemainingCount');
  const diceRemainingList = document.getElementById('diceRemainingList');
  const diceSavedList = document.getElementById('diceSavedList');

  const DICE_FACES = [];
  ['red', 'blue', 'green', 'yellow', 'white', 'black'].forEach((color) => {
    for (let face = 1; face <= 6; face++) DICE_FACES.push({ color, face: String(face) });
  });
  let diceCurrentIndex = 0;

  const TAB_STORAGE_KEY = 'symbol-labeling-tool-tab';
  function switchTab(tabId) {
    [panelAssets, panelCards, panelDice].forEach((p) => p.classList.remove('active'));
    [tabAssets, tabCards, tabDice].forEach((t) => t.classList.remove('active'));
    if (tabId === 'assets') { panelAssets.classList.add('active'); tabAssets.classList.add('active'); }
    else if (tabId === 'cards') { panelCards.classList.add('active'); tabCards.classList.add('active'); }
    else if (tabId === 'dice') {
      panelDice.classList.add('active'); tabDice.classList.add('active');
      showDiceFaceAtIndex(diceCurrentIndex);
      renderDiceSavedList();
      renderDiceRemainingList();
      loadDiceOutcomes();
    }
    try { localStorage.setItem(TAB_STORAGE_KEY, tabId); } catch (_) {}
  }
  tabAssets.addEventListener('click', () => switchTab('assets'));
  tabCards.addEventListener('click', () => switchTab('cards'));
  tabDice.addEventListener('click', () => switchTab('dice'));

  (function restoreTab() {
    try {
      const saved = localStorage.getItem(TAB_STORAGE_KEY);
      if (saved === 'cards' || saved === 'dice' || saved === 'assets') {
        [panelAssets, panelCards, panelDice].forEach((p) => p.classList.remove('active'));
        [tabAssets, tabCards, tabDice].forEach((t) => t.classList.remove('active'));
        if (saved === 'assets') { panelAssets.classList.add('active'); tabAssets.classList.add('active'); }
        else if (saved === 'cards') { panelCards.classList.add('active'); tabCards.classList.add('active'); }
        else if (saved === 'dice') {
          panelDice.classList.add('active'); tabDice.classList.add('active');
          showDiceFaceAtIndex(diceCurrentIndex);
          renderDiceSavedList();
          renderDiceRemainingList();
        }
      }
    } catch (_) {}
  })();

  async function loadGlossary() {
    const r = await fetch('/api/symbol-glossary');
    glossary = await r.json();
    if (!glossary.symbols) glossary.symbols = [];
    glossaryCount.textContent = glossary.symbols.length;
    renderGlossaryPreview();
    return glossary;
  }

  function formatGlossaryLine(s) {
    const label = s.label || '—';
    if (s.notes && /Die:\s*(\w+).*Face:\s*(\d+)/i.test(s.notes)) {
      const m = s.notes.match(/Die:\s*(\w+).*Face:\s*(\d+)/i);
      return (m[1] + ' face ' + m[2] + ': ' + label).trim();
    }
    if (s.notes && s.notes.trim()) return s.notes.trim() + ' — ' + label;
    return label;
  }

  function renderGlossaryPreview() {
    glossaryPreview.innerHTML = '';
    const ul = document.createElement('ul');
    ul.className = 'glossary-list';
    glossary.symbols.forEach((s, i) => {
      const li = document.createElement('li');
      const src = s.imagePath ? (s.imagePath.startsWith('symbol-images/') ? '/data/' + s.imagePath : '/' + s.imagePath) : '';
      const lineText = formatGlossaryLine(s);
      li.innerHTML = (src ? `<img src="${src.replace(/"/g, '&quot;')}" alt="">` : '') + `<span class="line-text">${escapeHtml(lineText)}</span><span class="del">Remove</span>`;
      li.querySelector('.del').addEventListener('click', () => { glossary.symbols.splice(i, 1); renderGlossaryPreview(); glossaryCount.textContent = glossary.symbols.length; });
      ul.appendChild(li);
    });
    glossaryPreview.appendChild(ul);
  }

  function escapeHtml(s) {
    const d = document.createElement('div');
    d.textContent = s;
    return d.innerHTML;
  }

  async function loadAssetList() {
    const r = await fetch('/api/symbol-asset-list');
    const data = await r.json();
    assetList.innerHTML = '';
    assetRows = [];
    ['dice', 'tokens', 'conditions'].forEach(key => {
      const items = data[key] || [];
      if (items.length === 0) return;
      const section = document.createElement('div');
      section.className = 'asset-section';
      section.innerHTML = `<h3>${key}</h3>`;
      items.forEach((item) => {
        const existing = glossary.symbols.find((s) => s.imagePath === item.path);
        const row = document.createElement('div');
        row.className = 'asset-row';
        row.innerHTML = `
          <img src="/${item.path}" alt="" onerror="this.style.background='#333'">
          <input type="text" data-path="${escapeHtml(item.path)}" value="${escapeHtml(existing ? existing.label : item.suggestedLabel)}" placeholder="Label">
          <select data-path="${escapeHtml(item.path)}">
            <option value="attack-die" ${(existing ? existing.category : item.suggestedCategory) === 'attack-die' ? 'selected' : ''}>Attack die</option>
            <option value="defense-die" ${(existing ? existing.category : item.suggestedCategory) === 'defense-die' ? 'selected' : ''}>Defense die</option>
            <option value="surge" ${(existing ? existing.category : item.suggestedCategory) === 'surge' ? 'selected' : ''}>Surge</option>
            <option value="keyword" ${(existing ? existing.category : item.suggestedCategory) === 'keyword' ? 'selected' : ''}>Keyword</option>
            <option value="passive" ${(existing ? existing.category : item.suggestedCategory) === 'passive' ? 'selected' : ''}>Passive</option>
            <option value="other" ${(existing ? existing.category : item.suggestedCategory) === 'other' ? 'selected' : ''}>Other</option>
          </select>
        `;
        section.appendChild(row);
        assetRows.push({ path: item.path, input: row.querySelector('input'), select: row.querySelector('select') });
      });
      assetList.appendChild(section);
    });
  }

  saveAssetsBtn.addEventListener('click', async () => {
    const byPath = {};
    glossary.symbols.forEach((s) => {
      if (s.imagePath && !s.imagePath.startsWith('symbol-images/')) byPath[s.imagePath] = s;
    });
    assetRows.forEach(({ path, input, select }) => {
      const label = input.value.trim();
      if (!label) return;
      byPath[path] = { id: label.toLowerCase().replace(/\s+/g, '-'), label, category: select.value, sourcePath: path };
    });
    const fromAssets = Object.values(byPath);
    const fromCrops = glossary.symbols.filter((s) => s.imagePath && s.imagePath.startsWith('symbol-images/'));
    glossary.symbols = [...fromCrops, ...fromAssets];
    const res = await fetch('/api/save-symbol-glossary', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ source: 'Symbol Labeling Tool', symbols: glossary.symbols }),
    });
    const result = await res.json();
    if (result.ok) {
      await loadGlossary();
      assetsStatus.textContent = 'Saved.';
      assetsStatus.className = 'status ok';
    } else {
      assetsStatus.textContent = result.error || 'Error';
      assetsStatus.className = 'status err';
    }
  });

  async function loadCardList() {
    const r = await fetch('/data/dc-images.json');
    const data = await r.json();
    cardList = Object.keys(data.dcImages || {}).sort();
    cardSelect.innerHTML = '<option value="">— Select a card —</option>' + cardList.map((n) => `<option value="${escapeHtml(n)}">${escapeHtml(n)}</option>`).join('');
  }

  cardSelect.addEventListener('change', () => {
    const name = cardSelect.value;
    if (!name) {
      cardImageWrap.style.display = 'none';
      cropForm.style.display = 'none';
      return;
    }
    cardImage.src = '/api/dc-image/' + encodeURIComponent(name);
    cardImageWrap.style.display = 'inline-block';
    cropForm.style.display = 'block';
    cropRect = null;
    cardImage.onload = () => {
      boxCanvas.width = cardImage.offsetWidth;
      boxCanvas.height = cardImage.offsetHeight;
      drawBox();
    };
  });

  overlay.addEventListener('mousedown', (e) => {
    const rect = overlay.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    drag = { x1: x, y1: y, x2: x, y2: y };
  });
  overlay.addEventListener('mousemove', (e) => {
    if (!drag) return;
    const rect = overlay.getBoundingClientRect();
    drag.x2 = e.clientX - rect.left;
    drag.y2 = e.clientY - rect.top;
    drawBox();
  });
  overlay.addEventListener('mouseup', () => {
    if (!drag) return;
    const x1 = Math.min(drag.x1, drag.x2);
    const y1 = Math.min(drag.y1, drag.y2);
    const x2 = Math.max(drag.x1, drag.x2);
    const y2 = Math.max(drag.y1, drag.y2);
    if (x2 - x1 > 4 && y2 - y1 > 4) cropRect = { x1, y1, x2, y2 };
    drag = null;
    drawBox();
  });

  function drawBox() {
    const ctx = boxCanvas.getContext('2d');
    ctx.clearRect(0, 0, boxCanvas.width, boxCanvas.height);
    const r = drag || cropRect;
    if (r) {
      const x1 = Math.min(r.x1, r.x2);
      const y1 = Math.min(r.y1, r.y2);
      const w = Math.abs(r.x2 - r.x1);
      const h = Math.abs(r.y2 - r.y1);
      ctx.strokeStyle = '#0d6efd';
      ctx.lineWidth = 2;
      ctx.strokeRect(x1, y1, w, h);
    }
  }

  addCropBtn.addEventListener('click', async () => {
    if (!cropRect || !cardImage.complete) {
      cropStatus.textContent = 'Draw a box on the card first.';
      cropStatus.className = 'status err';
      return;
    }
    const label = cropLabel.value.trim();
    if (!label) {
      cropStatus.textContent = 'Enter a label.';
      cropStatus.className = 'status err';
      return;
    }
    const scaleX = cardImage.naturalWidth / cardImage.offsetWidth;
    const scaleY = cardImage.naturalHeight / cardImage.offsetHeight;
    const c = document.createElement('canvas');
    c.width = Math.max(1, (cropRect.x2 - cropRect.x1) * scaleX);
    c.height = Math.max(1, (cropRect.y2 - cropRect.y1) * scaleY);
    const ctx = c.getContext('2d');
    ctx.drawImage(cardImage,
      cropRect.x1 * scaleX, cropRect.y1 * scaleY, c.width, c.height,
      0, 0, c.width, c.height);
    const dataUrl = c.toDataURL('image/png');
    const id = label.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
    glossary.symbols.push({
      id: id || 'symbol',
      label,
      category: cropCategory.value,
      imageBase64: dataUrl,
    });
    glossaryCount.textContent = glossary.symbols.length;
    renderGlossaryPreview();
    cropLabel.value = '';
    cropRect = null;
    drawBox();
    cropStatus.textContent = 'Added. Click Save glossary to file to write to disk.';
    cropStatus.className = 'status ok';
  });

  saveGlossaryBtn.addEventListener('click', async () => {
    const res = await fetch('/api/save-symbol-glossary', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ source: 'Symbol Labeling Tool', symbols: glossary.symbols }),
    });
    const result = await res.json();
    if (result.ok) {
      await loadGlossary();
      cropStatus.textContent = 'Saved.';
      cropStatus.className = 'status ok';
    } else {
      cropStatus.textContent = result.error || 'Error';
      cropStatus.className = 'status err';
    }
  });

  function formatDiceFaceSuggested(color, faceNum) {
    const c = color.toLowerCase();
    const f = parseInt(faceNum, 10) - 1;
    if (diceData.attack[c] && diceData.attack[c][f]) {
      const x = diceData.attack[c][f];
      const parts = [];
      if (x.acc > 0) parts.push('+' + x.acc + ' Accuracy');
      if (x.dmg > 0) parts.push('+' + x.dmg + ' Hit');
      if (x.surge > 0) parts.push('+' + x.surge + ' Surge');
      return parts.length ? parts.join(', ') : '0';
    }
    if (diceData.defense[c] && diceData.defense[c][f]) {
      const x = diceData.defense[c][f];
      const parts = [];
      if (x.block > 0) parts.push('+' + x.block + ' Block');
      if (x.evade > 0) parts.push('+' + x.evade + ' Evade');
      return parts.length ? parts.join(', ') : '0';
    }
    return '';
  }

  function showDiceFaceAtIndex(i) {
    diceCurrentIndex = Math.max(0, Math.min(i, DICE_FACES.length - 1));
    const { color, face } = DICE_FACES[diceCurrentIndex];
    const cap = color.charAt(0).toUpperCase() + color.slice(1);
    const path = `vassal_extracted/images/dice/Dice-${cap} ${face}.jpg`;
    diceFaceImage.src = '/' + encodeURI(path);
    diceFaceImage.alt = cap + ' die face ' + face;
    diceProgress.textContent = `${cap} die — Face ${face} of 6  ·  ${diceCurrentIndex + 1} of ${DICE_FACES.length}`;
    const estimate = formatDiceFaceSuggested(color, face);
    diceEstimate.textContent = estimate ? 'Our estimate: ' + estimate : '';
    const saved = (diceOutcomes[color] && diceOutcomes[color][face]) || '';
    diceOutcomeInput.value = saved || estimate;
    diceFaceStatus.textContent = '';
    dicePrevBtn.disabled = diceCurrentIndex === 0;
  }

  async function loadDiceOutcomes() {
    try {
      const r = await fetch('/api/dice-face-outcomes');
      const data = await r.json();
      diceOutcomes = data.outcomes || {};
    } catch {
      diceOutcomes = {};
    }
    renderDiceSavedList();
    renderDiceRemainingList();
    const firstRemainingIdx = DICE_FACES.findIndex(({ color, face }) => !(diceOutcomes[color] && diceOutcomes[color][face]));
    showDiceFaceAtIndex(firstRemainingIdx >= 0 ? firstRemainingIdx : 0);
  }

  function renderDiceSavedList() {
    const entries = [];
    DICE_FACES.forEach(({ color, face }) => {
      const text = (diceOutcomes[color] && diceOutcomes[color][face]) || '';
      if (text) entries.push({ color, face, text });
    });
    diceSavedList.innerHTML = entries.map((e) => {
      const cap = e.color.charAt(0).toUpperCase() + e.color.slice(1);
      return `<li><strong>${cap}: Face ${e.face}</strong> — ${escapeHtml(e.text)}</li>`;
    }).join('') || '<li class="hint">None yet.</li>';
  }

  function renderDiceRemainingList() {
    const remaining = DICE_FACES.filter(({ color, face }) => !(diceOutcomes[color] && diceOutcomes[color][face]));
    diceRemainingCount.textContent = remaining.length;
    diceRemainingList.innerHTML = '';
    remaining.forEach(({ color, face }) => {
      const idx = DICE_FACES.findIndex((f) => f.color === color && f.face === face);
      const cap = color.charAt(0).toUpperCase() + color.slice(1);
      const el = document.createElement('span');
      el.className = 'entry';
      el.textContent = cap + ': Face ' + face;
      el.addEventListener('click', () => showDiceFaceAtIndex(idx));
      diceRemainingList.appendChild(el);
    });
  }

  dicePrevBtn.addEventListener('click', () => showDiceFaceAtIndex(diceCurrentIndex - 1));

  async function saveDiceOutcomesAndUpdateUI(thenAdvance) {
    const { color, face } = DICE_FACES[diceCurrentIndex];
    const text = diceOutcomeInput.value.trim();
    if (!text) {
      diceFaceStatus.textContent = 'Enter or confirm what this face indicates.';
      diceFaceStatus.className = 'status err';
      return false;
    }
    if (!diceOutcomes[color]) diceOutcomes[color] = {};
    diceOutcomes[color][face] = text;
    renderDiceSavedList();
    renderDiceRemainingList();
    diceFaceStatus.textContent = 'Saving…';
    diceFaceStatus.className = 'status';
    try {
      const res = await fetch('/api/save-dice-face-outcomes', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ source: 'Symbol Labeling Tool', outcomes: diceOutcomes }),
      });
      const result = await res.json().catch(() => ({}));
      if (res.ok && result.ok) {
        diceFaceStatus.textContent = 'Saved.';
        diceFaceStatus.className = 'status ok';
        if (thenAdvance) {
          if (diceCurrentIndex < DICE_FACES.length - 1) showDiceFaceAtIndex(diceCurrentIndex + 1);
          else diceFaceStatus.textContent = diceRemainingCount.textContent === '0' ? 'All 36 faces verified.' : 'Use Previous or click a remaining face to continue.';
        }
        return true;
      } else {
        const msg = result.error || (res.status === 404 ? 'Server route not found. Open this page from http://localhost:3456/scripts/symbol-labeling-tool.html (run: npm run cc-review).' : res.status ? 'Save failed (' + res.status + ').' : 'Save failed.');
        diceFaceStatus.textContent = msg;
        diceFaceStatus.className = 'status err';
        return false;
      }
    } catch (e) {
      diceFaceStatus.textContent = 'Network error. Open from http://localhost:3456/scripts/symbol-labeling-tool.html (run: npm run cc-review).';
      diceFaceStatus.className = 'status err';
      return false;
    }
  }

  diceUpdateBtn.addEventListener('click', () => saveDiceOutcomesAndUpdateUI(false));
  diceVerifyBtn.addEventListener('click', () => saveDiceOutcomesAndUpdateUI(true));

  (async function init() {
    try {
      const r = await fetch('/data/dice.json');
      const d = await r.json();
      diceData.attack = d.attack || {};
      diceData.defense = d.defense || {};
    } catch {
      diceData = { attack: {}, defense: {} };
    }
    await loadGlossary();
    await loadAssetList();
    await loadCardList();
    try {
      const saved = localStorage.getItem(TAB_STORAGE_KEY);
      if (saved === 'dice') loadDiceOutcomes();
    } catch (_) {}
  })();
})();
  </script>
</body>
</html>
