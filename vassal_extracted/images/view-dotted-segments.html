<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dotted segments (movement-blocking) — Mos Eisley</title>
  <style>
    body { font-family: sans-serif; padding: 16px; background: #1a1a1a; color: #eee; }
    h1 { font-size: 1.2rem; }
    .wrap { display: flex; flex-wrap: wrap; align-items: flex-start; gap: 16px; }
    .container { position: relative; display: inline-block; }
    #mapImg { display: block; max-width: 1100px; }
    #overlay { position: absolute; left: 0; top: 0; pointer-events: none; }
    .legend { min-width: 260px; background: #2a2a2a; padding: 12px; border-radius: 8px; }
    .legend h2 { margin: 0 0 8px 0; font-size: 1rem; color: #ccc; }
    .legend ul { list-style: none; padding: 0; margin: 0; }
    .legend li { padding: 4px 0; display: flex; align-items: center; gap: 8px; }
    .legend .swatch { width: 20px; height: 8px; border-radius: 2px; flex-shrink: 0; }
    .legend .label { font-family: monospace; font-size: 0.9rem; }
    button { padding: 8px 14px; margin-bottom: 8px; cursor: pointer; }
    #status { margin-bottom: 8px; color: #9f9; font-size: 0.9rem; }
  </style>
</head>
<body>
  <h1>Dotted red segments (movement-blocking edges)</h1>
  <p id="status">Load <strong>map-spaces.json</strong> to draw segments on the map. Check each segment against the board.</p>
  <button id="loadBtn">Load map-spaces.json</button>
  <input type="file" id="fileInput" accept=".json" style="display:none">

  <div class="wrap">
    <div class="container">
      <img id="mapImg" src="Map_Mos Eisley Outskirts.gif" alt="Map">
      <canvas id="overlay"></canvas>
    </div>
    <div class="legend">
      <h2>Segments (by number on map)</h2>
      <ul id="legendList"></ul>
    </div>
  </div>

  <script>
    const img = document.getElementById('mapImg');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const dx = 50, dy = 50, x0 = 25, y0 = 25;
    let scale = 1;
    let segments = []; // array of { chain: ['r13','r14'], color: '#f00' }

    function coordToColRow(s) {
      const c = String(s).toLowerCase();
      const col = c.charCodeAt(0) - 97;
      const row = parseInt(c.slice(1), 10) - 1;
      return { col, row };
    }

    function edgeKey(a, b) {
      return [String(a).toLowerCase(), String(b).toLowerCase()].sort().join('|');
    }

    function buildSegmentsFromEdges(edges) {
      if (!edges || edges.length === 0) return [];
      const edgeSet = new Set(edges.map(e => edgeKey(e[0], e[1])));
      const graph = new Map(); // coord -> [neighbor coords]
      for (const [a, b] of edges) {
        const x = String(a).toLowerCase(), y = String(b).toLowerCase();
        if (!graph.has(x)) graph.set(x, []);
        if (!graph.has(y)) graph.set(y, []);
        graph.get(x).push(y);
        graph.get(y).push(x);
      }
      const visited = new Set();
      const segmentsOut = [];
      const colors = [
        '#e74c3c', '#f39c12', '#2ecc71', '#3498db', '#9b59b6',
        '#1abc9c', '#e67e22', '#f1c40f', '#e91e63'
      ];
      let colorIdx = 0;
      for (const start of graph.keys()) {
        if (visited.has(start)) continue;
        const stack = [start];
        visited.add(start);
        const component = [start];
        while (stack.length > 0) {
          const u = stack.pop();
          for (const v of graph.get(u) || []) {
            if (!visited.has(v)) {
              visited.add(v);
              component.push(v);
              stack.push(v);
            }
          }
        }
        const chain = orderChain(component, graph);
        segmentsOut.push({
          chain,
          color: colors[colorIdx % colors.length]
        });
        colorIdx++;
      }
      return segmentsOut;
    }

    function orderChain(nodes, graph) {
      if (nodes.length <= 2) return nodes;
      const degree = new Map();
      for (const n of nodes) {
        degree.set(n, (graph.get(n) || []).filter(x => nodes.includes(x)).length);
      }
      const ends = nodes.filter(n => degree.get(n) === 1);
      if (ends.length === 0) return nodes;
      const start = ends[0];
      const out = [start];
      const seen = new Set([start]);
      while (out.length < nodes.length) {
        const cur = out[out.length - 1];
        const next = (graph.get(cur) || []).find(x => nodes.includes(x) && !seen.has(x));
        if (!next) break;
        seen.add(next);
        out.push(next);
      }
      return out;
    }

    function getEdgeLine(a, b, sdx, sdy, sx0, sy0) {
      const u = coordToColRow(a), v = coordToColRow(b);
      const dc = Math.abs(u.col - v.col), dr = Math.abs(u.row - v.row);
      if (dc + dr !== 1) return null;
      if (dc === 0) {
        const col = u.col;
        const rMin = Math.min(u.row, v.row);
        const y = sy0 + (rMin + 1) * sdy;
        const x1 = sx0 + col * sdx;
        const x2 = sx0 + (col + 1) * sdx;
        return { x1, y1: y, x2, y2: y };
      } else {
        const row = u.row;
        const cMin = Math.min(u.col, v.col);
        const x = sx0 + (cMin + 1) * sdx;
        const y1 = sy0 + row * sdy;
        const y2 = sy0 + (row + 1) * sdy;
        return { x1: x, y1, x2: x, y2 };
      }
    }

    function draw() {
      const w = overlay.width, h = overlay.height;
      if (!w || !h) return;
      ctx.clearRect(0, 0, w, h);
      const sdx = dx * scale, sdy = dy * scale, sx0 = x0 * scale, sy0 = y0 * scale;

      for (let i = 0; i < segments.length; i++) {
        const seg = segments[i];
        const chain = seg.chain;
        ctx.strokeStyle = seg.color;
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.setLineDash([8, 6]);
        for (let j = 0; j < chain.length - 1; j++) {
          const line = getEdgeLine(chain[j], chain[j + 1], sdx, sdy, sx0, sy0);
          if (line) {
            ctx.beginPath();
            ctx.moveTo(line.x1, line.y1);
            ctx.lineTo(line.x2, line.y2);
            ctx.stroke();
          }
        }
        ctx.setLineDash([]);
        const midIdx = Math.floor((chain.length - 1) / 2);
        const a = chain[midIdx], b = chain[midIdx + 1] || chain[midIdx];
        const line = getEdgeLine(a, b, sdx, sdy, sx0, sy0) || getEdgeLine(chain[0], chain[1], sdx, sdy, sx0, sy0);
        if (line) {
          const mx = (line.x1 + line.x2) / 2, my = (line.y1 + line.y2) / 2;
          ctx.fillStyle = seg.color;
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.font = 'bold 14px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const num = String(i + 1);
          ctx.strokeText(num, mx, my);
          ctx.fillText(num, mx, my);
        }
      }
    }

    function renderLegend() {
      const ul = document.getElementById('legendList');
      ul.innerHTML = '';
      segments.forEach((seg, i) => {
        const li = document.createElement('li');
        const swatch = document.createElement('span');
        swatch.className = 'swatch';
        swatch.style.background = seg.color;
        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = (i + 1) + '. ' + seg.chain.map(c => c.toUpperCase()).join('–');
        li.appendChild(swatch);
        li.appendChild(label);
        ul.appendChild(li);
      });
    }

    function init() {
      const w = img.naturalWidth, h = img.naturalHeight;
      if (!w || !h) return;
      scale = Math.min(1, 1100 / w);
      const sw = Math.round(w * scale), sh = Math.round(h * scale);
      overlay.width = sw;
      overlay.height = sh;
      overlay.style.width = sw + 'px';
      overlay.style.height = sh + 'px';
      draw();
      renderLegend();
    }

    document.getElementById('loadBtn').onclick = () => document.getElementById('fileInput').click();
    document.getElementById('fileInput').onchange = (e) => {
      const f = e.target.files[0];
      if (!f) return;
      const r = new FileReader();
      r.onload = () => {
        try {
          const data = JSON.parse(r.result);
          const mapData = data.maps?.['mos-eisley-outskirts'] || data;
          const edges = mapData.movementBlockingEdges || [];
          segments = buildSegmentsFromEdges(edges);
          document.getElementById('status').textContent = 'Loaded. ' + segments.length + ' segment(s) drawn. Check numbers on the map against the legend.';
          init();
        } catch (err) {
          document.getElementById('status').textContent = 'Load error: ' + err.message;
        }
      };
      r.readAsText(f);
    };

    img.onload = init;
    img.onerror = () => { document.getElementById('status').textContent = 'Could not load map image.'; };
    if (img.complete) init();
  </script>
</body>
</html>
