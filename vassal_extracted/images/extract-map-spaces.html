<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Map Spaces / Terrain Extractor</title>
  <style>
    body { font-family: sans-serif; padding: 16px; background: #222; color: #eee; }
    .toolbar { margin: 12px 0; }
    button { padding: 8px 16px; margin-right: 8px; cursor: pointer; }
    .container { position: relative; display: inline-block; min-height: 200px; }
    #mapImg { display: block; max-width: 1200px; }
    #overlay { position: absolute; left: 0; top: 0; cursor: crosshair; user-select: none; z-index: 1; }
    #status { margin: 8px 0; color: #9f9; }
    .mode { margin-right: 12px; }
    label { cursor: pointer; }
    #colorKey { margin: 8px 0 12px 0; font-size: 0.85em; color: #bbb; display: flex; flex-wrap: wrap; gap: 10px 16px; align-items: center; }
    #colorKey span { display: inline-flex; align-items: center; gap: 4px; }
    #colorKey .swatch { width: 14px; height: 14px; border-radius: 2px; border: 1px solid rgba(255,255,255,0.3); }
    #status.saved-flash { background: rgba(0,180,0,0.25); border-radius: 4px; padding: 4px 8px; transition: background 0.4s ease; }
    .main-layout { display: flex; flex-direction: row; align-items: flex-start; gap: 10px; flex-wrap: wrap; }
    .left-column { flex: 1 1 0; min-width: 360px; }
    .mission-panel { width: 560px; flex-shrink: 0; background: #2a2a2a; padding: 16px; border-radius: 8px; border: 1px solid #444; }
    .mission-panel h3 { margin: 0 0 12px 0; font-size: 1em; color: #9cf; border-bottom: 1px solid #444; padding-bottom: 6px; }
    .mission-panel .mission-variant-row { margin-bottom: 10px; }
    .mission-panel .mission-variant-row .mode-label { margin-right: 12px; }
    .mission-panel .mission-variant-row .mode-label input { margin-right: 4px; }
    .mission-panel .mission-field { margin-bottom: 12px; }
    .mission-panel .mission-field label { display: block; margin-bottom: 4px; font-size: 0.9em; color: #bbb; }
    .mission-panel .mission-field input[type="text"] { width: 100%; max-width: 520px; box-sizing: border-box; padding: 6px 8px; background: #1a1a1a; border: 1px solid #555; color: #eee; border-radius: 4px; }
    .mission-panel .mission-text-section { margin: 14px 0; padding-top: 10px; border-top: 1px solid #444; }
    .mission-panel .mission-text-field { margin-bottom: 10px; }
    .mission-panel .mission-text-field label { display: block; margin-bottom: 4px; font-size: 0.9em; color: #bbb; }
    .mission-panel .mission-text-field textarea { width: 100%; max-width: 520px; box-sizing: border-box; padding: 6px 8px; background: #1a1a1a; border: 1px solid #555; color: #eee; border-radius: 4px; resize: vertical; min-height: 2.5em; font-family: inherit; }
    .mission-panel .mission-modes { margin: 14px 0; }
    .mission-panel .mission-modes .mode-label { display: block; margin: 6px 0; }
    .mission-panel .mission-modes .mode-label input { margin-right: 8px; }
    .mission-panel .named-area-row { margin-top: 14px; padding-top: 12px; border-top: 1px solid #444; }
    .mission-panel .named-area-row label { display: block; margin-bottom: 6px; font-size: 0.9em; }
    .mission-panel .named-area-row input, .mission-panel .named-area-row select { margin-right: 8px; margin-bottom: 6px; padding: 4px 8px; background: #1a1a1a; border: 1px solid #555; color: #eee; border-radius: 4px; }
    .mission-panel #addNamedAreaBtn { margin-top: 8px; }
    .mission-panel .named-area-list { margin-top: 12px; font-size: 0.85em; }
    .mission-panel .named-area-list .area-item { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
    .mission-panel .named-area-list .area-item .area-label { flex: 1; min-width: 0; }
    .mission-panel .named-area-list .area-swatch { width: 16px; height: 16px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.3); flex-shrink: 0; }
    .mission-panel .named-area-list .area-delete-btn { flex-shrink: 0; width: 20px; height: 20px; padding: 0; border: 1px solid #555; border-radius: 4px; background: #444; color: #ccc; cursor: pointer; font-size: 14px; line-height: 1; display: inline-flex; align-items: center; justify-content: center; }
    .mission-panel .named-area-list .area-delete-btn:hover { background: #663333; color: #fff; border-color: #885555; }
  </style>
</head>
<body>
  <h1>Map Spaces — Terrain & Walls</h1>
  <p id="status">Load map-spaces.json. Off-map: click or drag to exclude/restore cells. Terrain: click to cycle. Edges: click for walls.</p>
  <p style="margin:4px 0 8px 0; font-size:0.9em; color:#999;">Run <code>npm run map-tool</code> in the project folder — the map tool opens in your browser. Use the single <strong>Save</strong> button to save everything (map spaces, rotation, deployment zones, mission tokens) to the project <code>data/</code> folder. Token images (terminals, panels, contraband) show on the map when present in <code>vassal_extracted/images/tokens/</code> or <code>maps/</code> — see <code>data/token-images.json</code> for filenames; otherwise colored shapes are used.</p>
  <div class="main-layout">
    <div class="left-column">
      <div id="colorKey" title="Grid overlay legend">
        <span><span class="swatch" style="background:#505050;"></span> Off-map</span>
        <span><span class="swatch" style="background:rgba(100,149,237,0.65);"></span> Difficult terrain</span>
        <span><span class="swatch" style="background:rgba(220,53,69,0.7);"></span> Blocking</span>
        <span><span class="swatch" style="background:rgba(50,205,50,0.6);"></span> Exterior</span>
        <span><span class="swatch" style="background:rgba(220,53,69,0.6);"></span> Red deployment zone</span>
        <span><span class="swatch" style="background:rgba(13,110,253,0.6);"></span> Blue deployment zone</span>
        <span><span class="swatch" style="background:rgba(255,255,0,0.9);"></span> Solid wall</span>
        <span><span class="swatch" style="background:rgba(255,100,100,0.8);"></span> Movement-blocking edge</span>
      </div>
      <div class="toolbar">
        <label>Map: <select id="mapSelect" title="Select which map to configure"></select></label>
        <span class="mode" style="margin-left:8px"><label title="Include this map in competitive rotation; saved when you press Save"><input type="checkbox" id="inRotationCheckbox"> In competitive rotation</label></span>
        <span class="mode" style="margin-left:8px"><label title="Include this map in the random/draw pool in Discord; saved when you press Save"><input type="checkbox" id="playReadyCheckbox"> Play ready?</label></span>
        <button id="saveBtn" style="background:#0a0;color:#fff;font-weight:bold">Save</button>
        <span id="saveFallbackWrap" style="display:none; margin-left:8px;"><button id="downloadDataBtn" type="button" style="background:#666;color:#fff;">Save to file</button></span>
      </div>
      <div id="mapSpacesToolbar" class="toolbar">
        <span class="mode"><label><input type="radio" name="mode" value="offmap" checked> Off-map (click to exclude)</label></span>
        <span class="mode"><label><input type="radio" name="mode" value="terrain"> Terrain (normal → difficult → blocking)</label></span>
        <span class="mode"><label><input type="radio" name="mode" value="edge"> Edge (solid wall → dotted → clear)</label></span>
        <span class="mode"><label><input type="radio" name="mode" value="exterior"> Exterior (green = exterior; click or drag to paint/clear)</label></span>
        <span class="mode" id="deploymentZoneWrap"><label><input type="radio" name="mode" value="deploymentzone"> Deployment zone (click to cycle red → blue → clear; drag to paint)</label></span>
      </div>
      <div class="container">
        <img id="mapImg" src="maps/Map_Mos Eisley Outskirts.gif" alt="Map">
        <canvas id="overlay"></canvas>
      </div>
    </div>
    <aside id="missionPanel" class="mission-panel" aria-label="Mission configuration">
      <h3>Mission</h3>
      <div class="mission-variant-row">
        <span class="mode-label"><label><input type="radio" name="missionVariant" value="a" checked> Mission A</label></span>
        <span class="mode-label"><label><input type="radio" name="missionVariant" value="b"> Mission B</label></span>
      </div>
      <div class="mission-field">
        <label for="missionNameInput">Mission name</label>
        <input type="text" id="missionNameInput" size="24" placeholder="e.g. A. Get to the Ship" title="Display name for selected mission variant">
      </div>
      <div class="mission-field">
        <label for="missionTokenLabelInput">Token label</label>
        <input type="text" id="missionTokenLabelInput" size="24" placeholder="e.g. Launch panels, Contraband" title="Label for this mission's tokens (shown in mode and saved with mission card)">
      </div>
      <div class="mission-text-section">
        <div class="mission-text-field">
          <label for="missionSetupInput">Setup</label>
          <textarea id="missionSetupInput" rows="2" placeholder="Mission setup text" title="Setup instructions for this mission variant"></textarea>
        </div>
        <div class="mission-text-field">
          <label for="missionStartOfRoundInput">Start of round</label>
          <textarea id="missionStartOfRoundInput" rows="2" placeholder="Start of round effects" title="Effects that happen at the start of each round"></textarea>
        </div>
        <div class="mission-text-field">
          <label for="missionEndOfRoundInput">End of round</label>
          <textarea id="missionEndOfRoundInput" rows="2" placeholder="End of round effects" title="Effects that happen at the end of each round"></textarea>
        </div>
      </div>
      <div class="mission-modes">
        <span class="mode-label"><label><input type="radio" name="mode" value="terminal"> Terminals</label></span>
        <span class="mode-label"><label><input type="radio" name="mode" value="missionTokens"> Mission tokens</label></span>
        <span class="mode-label"><label title="One edge = one door between 2 cells. In game, connected colinear edges share one door image. Opening: figure must be on or orthogonally adjacent to one of the 2 cells (no diagonal)."><input type="radio" name="mode" value="doors"> Doors (click edge)</label></span>
        <span class="mode-label"><label><input type="radio" name="mode" value="namedarea"> Named area (paint cells)</label></span>
      </div>
      <div class="named-area-row">
        <label for="namedAreaSelect">Area</label>
        <select id="namedAreaSelect" title="Which named area to paint"><option value="0">Area 1</option></select>
        <label for="namedAreaName">Name</label>
        <input type="text" id="namedAreaName" size="12" placeholder="Area name" title="Rename selected area">
        <button type="button" id="addNamedAreaBtn" title="Add a new named area">+ Area</button>
      </div>
      <div id="namedAreaList" class="named-area-list" title="Named areas (each has a distinct color on the map)"></div>
    </aside>
  </div>
  <!-- INJECT_MAP_SPACES -->
  <!-- INJECT_MAP_IMAGE_PATHS -->
  <!-- INJECT_TOURNAMENT_ROTATION -->
  <!-- INJECT_DEPLOYMENT_ZONES -->
  <!-- INJECT_MAP_TOKENS -->
  <!-- INJECT_TOKEN_IMAGES --><script type="application/json" id="token-images-data">{"terminals":"Counter--Terminal Blue.gif","missionA":"Mission Token--Neutral GRAY.gif","missionB":"Counter--Crate Blue.gif","doors":"Token--Door.png"}</script>
  <!-- INJECT_MISSION_CARDS --><script type="application/json" id="mission-cards-data">{"source":"extract-map-spaces.html","maps":{}}</script>
  <script>
    const img = document.getElementById('mapImg');
    // If default src is old path without maps/ (e.g. cached HTML), fix it so image loads from images/maps/
    (function () {
      const s = img.getAttribute('src') || '';
      if (s && s.includes('Map_') && !s.includes('maps/') && !s.startsWith('http')) img.setAttribute('src', 'maps/' + s.replace(/^.*[/\\]/, ''));
    })();
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const dx = 50, dy = 50, x0 = 25, y0 = 25;
    let scale = 1, numCols = 0, numRows = 0;
    let state = { spaces: [], adjacency: {}, terrain: {}, blocking: [], impassableEdges: [], movementBlockingEdges: [], offMap: [], exterior: {}, playReady: true };
    /** Full file data from last Load (or injected by map-tool server); used to preserve other maps on Export. */
    let fullMapData = (function () {
      const el = document.getElementById('map-spaces-data');
      if (el && el.textContent) try { return JSON.parse(el.textContent); } catch (e) {}
      return null;
    })();
    /** Map id -> image path (from map-registry, injected by server). Used to show map image when selecting from dropdown. */
    let mapImagePaths = (function () {
      const el = document.getElementById('map-image-paths');
      if (el && el.textContent) try { return JSON.parse(el.textContent); } catch (e) {}
      return {};
    })();
    /** Tournament rotation { source, missionIds }. Injected by map-tool server; missionIds is mutable. */
    let fullTournamentRotationData = (function () {
      const el = document.getElementById('tournament-rotation');
      if (el && el.textContent) {
        try {
          const parsed = JSON.parse(el.textContent);
          if (Array.isArray(parsed)) return { source: 'extract-map-spaces.html', missionIds: [...parsed] };
          if (parsed && typeof parsed.missionIds !== 'undefined') return { source: parsed.source || 'extract-map-spaces.html', missionIds: [...(parsed.missionIds || [])] };
        } catch (e) {}
      }
      return { source: 'extract-map-spaces.html', missionIds: [] };
    })();
    /** Full deployment zones { source, maps: { mapId: { red: [], blue: [] } } }. Injected by map-tool server. */
    let fullDeploymentZonesData = (function () {
      const el = document.getElementById('deployment-zones-data');
      if (el && el.textContent) try { return JSON.parse(el.textContent); } catch (e) {}
      return { source: 'extract-map-spaces.html', maps: {} };
    })();
    /** Current map's deployment zone coords (editable). Synced from fullDeploymentZonesData on map switch. */
    let deploymentZoneState = { red: [], blue: [] };
    /** Full map-tokens file (injected or loaded). */
    let fullMapTokensData = (function () {
      const el = document.getElementById('map-tokens-data');
      if (el && el.textContent) try { return JSON.parse(el.textContent); } catch (e) {}
      return { source: 'extract-map-spaces.html', maps: {} };
    })();
    /** Mission card names (and image paths) per map. Injected by server, or fallback/merge from localStorage so refresh keeps names. */
    const MISSION_CARDS_STORAGE_KEY = 'map-tool-mission-cards';
    let fullMissionCardsData = (function () {
      const el = document.getElementById('mission-cards-data');
      let data = { source: 'extract-map-spaces.html', maps: {} };
      if (el && el.textContent) {
        try {
          data = JSON.parse(el.textContent);
          if (!data || typeof data !== 'object') data = { source: 'extract-map-spaces.html', maps: {} };
          if (!data.maps || typeof data.maps !== 'object') data.maps = {};
        } catch (e) {}
      }
      if (typeof localStorage !== 'undefined') {
        try {
          const stored = localStorage.getItem(MISSION_CARDS_STORAGE_KEY);
          if (stored) {
            const parsed = JSON.parse(stored);
            if (parsed && parsed.maps && typeof parsed.maps === 'object') {
              if (!data.maps || Object.keys(data.maps).length === 0) {
                data = parsed;
              } else {
                for (const [mapId, mapEntry] of Object.entries(parsed.maps)) {
                  if (!data.maps[mapId]) data.maps[mapId] = mapEntry;
                }
              }
            }
          }
        } catch (e2) {}
        if (data.maps && Object.keys(data.maps).length > 0) {
          try { localStorage.setItem(MISSION_CARDS_STORAGE_KEY, JSON.stringify(data)); } catch (e3) {}
        }
      }
      return data;
    })();
    /** Current map's mission tokens (terminals, mission A/B, doors, named areas). Synced on map switch. */
    let missionTokenState = {
      terminals: [],
      missionA: { launchPanels: [] },
      missionB: { contraband: [] },
      doors: [],
      namedAreas: [{ id: 0, name: 'Area 1', cells: [] }]
    };
    /** Distinct colors for named areas (consecutive list); cycle if more areas than colors. */
    const AREA_COLORS = [
      'rgba(160,100,255,0.45)', 'rgba(79,195,247,0.45)', 'rgba(129,199,132,0.5)', 'rgba(255,183,77,0.5)',
      'rgba(244,143,177,0.5)', 'rgba(100,181,246,0.45)', 'rgba(165,214,167,0.5)', 'rgba(255,204,128,0.5)',
      'rgba(206,147,216,0.5)', 'rgba(77,208,225,0.45)', 'rgba(220,231,117,0.45)', 'rgba(239,154,154,0.5)'
    ];
    const AREA_BORDER_COLORS = [
      'rgba(180,140,255,0.95)', 'rgba(100,210,255,0.95)', 'rgba(160,220,160,0.95)', 'rgba(255,200,100,0.95)',
      'rgba(255,160,200,0.95)', 'rgba(130,200,255,0.95)', 'rgba(180,230,180,0.95)', 'rgba(255,220,150,0.95)',
      'rgba(220,180,230,0.95)', 'rgba(100,230,255,0.95)', 'rgba(240,245,140,0.95)', 'rgba(255,180,180,0.95)'
    ];
    /** Token image config from data/token-images.json (injected by map-tool server). */
    const tokenImagesConfig = (function () {
      const el = document.getElementById('token-images-data');
      if (el && el.textContent) try { return JSON.parse(el.textContent); } catch (e) {}
      return { terminals: 'Counter--Terminal Blue.gif', missionA: 'Mission Token--Neutral GRAY.gif', missionB: 'Counter--Crate Blue.gif', doors: 'Token--Door.png' };
    })();
    /** Preloaded token images (same filenames as game map renderer). Try tokens/, then maps/, then filename. Draw these on the overlay when loaded; otherwise colored shapes. */
    const tokenImgTerminals = new Image();
    const tokenImgMissionA = new Image();
    const tokenImgMissionB = new Image();
    const TOKEN_BASE_PATHS = ['tokens/', 'maps/', ''];
    function tryLoadTokenImg(imgEl, filename, pathIndex) {
      if (!filename) return;
      const base = TOKEN_BASE_PATHS[pathIndex || 0];
      const src = base + encodeURIComponent(filename);
      imgEl.onload = function () { draw(); };
      imgEl.onerror = function () {
        const next = (pathIndex || 0) + 1;
        if (next < TOKEN_BASE_PATHS.length) tryLoadTokenImg(imgEl, filename, next);
        else draw();
      };
      imgEl.src = src;
    }
    (function preloadTokenImages() {
      tryLoadTokenImg(tokenImgTerminals, tokenImagesConfig.terminals, 0);
      tryLoadTokenImg(tokenImgMissionA, tokenImagesConfig.missionA, 0);
      tryLoadTokenImg(tokenImgMissionB, tokenImagesConfig.missionB, 0);
    })();
    /** Draw a token at cell center: use image if loaded, else fallback colored shape. If label is provided, draw it on top with base at bottom of cell. */
    function drawTokenAt(ctx, img, fallbackShape, fallbackStyle, x, y, sdx, sdy, label) {
      const cx = x + sdx / 2, cy = y + sdy / 2;
      const tokenSize = Math.min(sdx, sdy) * 0.9;
      if (img && img.complete && img.naturalWidth) {
        const tw = img.naturalWidth, th = img.naturalHeight;
        const tScale = Math.min(tokenSize / tw, tokenSize / th);
        const dw = tw * tScale, dh = th * tScale;
        ctx.drawImage(img, cx - dw / 2, cy - dh / 2, dw, dh);
      } else {
        ctx.fillStyle = fallbackStyle;
        if (fallbackShape === 'circle') {
          ctx.beginPath();
          ctx.arc(cx, cy, tokenSize / 2 - 2, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.fillRect(cx - tokenSize / 2, cy - tokenSize / 2, tokenSize, tokenSize);
        }
      }
      if (label && String(label).trim()) {
        const fontSize = Math.max(8, Math.min(14, Math.round(11 * scale)));
        const cellBottom = y + sdy;
        ctx.font = `bold ${fontSize}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        const labelY = cellBottom - 2;
        ctx.strokeStyle = 'rgba(0,0,0,0.9)';
        ctx.lineWidth = 2;
        ctx.strokeText(label.trim(), cx, labelY);
        ctx.fillStyle = '#fff';
        ctx.fillText(label.trim(), cx, labelY);
        ctx.lineWidth = 1;
      }
    }
    /** Ensure path points to images/maps/ so map images load from the maps subfolder. */
    function mapImagePathForUrl(path) {
      if (!path) return path;
      if (path.includes('vassal_extracted/images/') && !path.includes('/maps/'))
        return path.replace('vassal_extracted/images/', 'vassal_extracted/images/maps/');
      return path;
    }
    /** In-memory mission data for current map (synced when switching variant or map). Used for save payload. */
    let missionANameValue = '';
    let missionBNameValue = '';
    let missionATokenLabel = '';
    let missionBTokenLabel = '';
    let missionASetup = '', missionBSetup = '';
    let missionAStartOfRound = '', missionBStartOfRound = '';
    let missionAEndOfRound = '', missionBEndOfRound = '';

    /** Mission card image paths must live under images/mission-cards/. Normalize so saved data always uses that subfolder. */
    function missionCardImagePath(path) {
      if (!path || typeof path !== 'string') return path || '';
      if (path.includes('/mission-cards/')) return path;
      const base = 'vassal_extracted/images/';
      if (path.startsWith(base)) {
        const filename = path.slice(base.length).replace(/^[^/]+[/\\]/, '');
        return base + 'mission-cards/' + (filename || path.split(/[/\\]/).pop() || '');
      }
      const filename = path.split(/[/\\]/).pop();
      return filename ? 'vassal_extracted/images/mission-cards/' + filename : path;
    }
    /** All maps from map-registry (id + name) so dropdown is always populated. */
    const ALL_MAPS = [{"id":"30th-floor-plaza","name":"30th Floor Plaza"},{"id":"anchorhead-cantina-bar","name":"Anchorhead Cantina/Bar"},{"id":"bespin-tibanna-facility","name":"Bespin Tibanna Facility"},{"id":"chopper-base-atollon","name":"Chopper Base, Atollon"},{"id":"climate-research-camp","name":"Climate Research Camp"},{"id":"corellian-underground","name":"Corellian Underground"},{"id":"coruscant-back-alleys","name":"Coruscant Back Alleys"},{"id":"coruscant-landfill","name":"Coruscant Landfill"},{"id":"coruscant-senate-office","name":"Coruscant Senate Office"},{"id":"devaron-garrison","name":"Devaron Garrison"},{"id":"development-facility","name":"Development Facility"},{"id":"the-dune-sea","name":"The Dune Sea"},{"id":"echo-base","name":"Echo Base"},{"id":"endor-defense-station","name":"Endor Defense Station"},{"id":"endor-wilderness","name":"Endor Wilderness"},{"id":"geonosis-foundry","name":"Geonosis Foundry"},{"id":"hangar-bay","name":"Hangar Bay"},{"id":"hoth-battle-station","name":"Hoth Battle Station"},{"id":"hoth-weather-shelter","name":"Hoth Weather Shelter"},{"id":"imperial-command-hub","name":"Imperial Command Hub"},{"id":"imperial-labor-camp","name":"Imperial Labor Camp"},{"id":"imperial-research-lab","name":"Imperial Research Lab"},{"id":"imperial-space-station","name":"Imperial Space Station"},{"id":"imperial-tower","name":"Imperial Tower"},{"id":"isb-headquarters","name":"ISB Headquarters"},{"id":"isb-training-grounds","name":"ISB Training Grounds"},{"id":"jabba-s-palace","name":"Jabba's Palace"},{"id":"kashyyyk-station","name":"Kashyyyk Station"},{"id":"kuat-space-station","name":"Kuat Space Station"},{"id":"lothal-battlefront","name":"Lothal Battlefront"},{"id":"lothal-safehouse","name":"Lothal Safehouse"},{"id":"lothal-spaceport","name":"Lothal Spaceport"},{"id":"lothal-wastes","name":"Lothal Wastes"},{"id":"massassi-ruins","name":"Massassi Ruins"},{"id":"moisture-farm","name":"Moisture Farm"},{"id":"mos-eisley-back-alleys","name":"Mos Eisley Back Alleys"},{"id":"mos-eisley-cantina","name":"Mos Eisley Cantina"},{"id":"mos-eisley-outskirts","name":"Mos Eisley Outskirts"},{"id":"nal-hutta-swamps","name":"Nal Hutta Swamps"},{"id":"nelvaanian-war-zone","name":"Nelvaanian War Zone"},{"id":"ord-mantell-junkyard","name":"Ord Mantell Junkyard"},{"id":"the-pit-of-carkoon","name":"The Pit of Carkoon"},{"id":"sewers-of-nar-shaddaa","name":"Sewers of Nar Shaddaa"},{"id":"tarkin-initiative-labs","name":"Tarkin Initiative Labs"},{"id":"training-ground","name":"Training Ground"},{"id":"tython-meditation-field","name":"Tython Meditation Field"},{"id":"uscru-entertainment-district","name":"Uscru Entertainment District"},{"id":"wasskah-hunting-ground","name":"Wasskah Hunting Ground"},{"id":"wasteland-outpost","name":"Wasteland Outpost"},{"id":"b-omarr-subterranean-passageways-3-player","name":"* B'Omarr Subterranean Passageways (3-player)"},{"id":"scarif-imperial-hotel-3-player","name":"* Scarif Imperial Hotel (3-player)"},{"id":"hoth-battlefield-4-player","name":"* Hoth Battlefield (4-player)"},{"id":"nal-hutta-borderlands-4-player","name":"* Nal Hutta Borderlands (4-player)"},{"id":"temple-gardens-4-player","name":"* Temple Gardens (4-player)"}];

    function colToLetter(c) { return c < 26 ? String.fromCharCode(65 + c) : colToLetter(Math.floor(c/26)-1) + colToLetter(c%26); }
    function coordKey(col, row) { return colToLetter(col).toLowerCase() + (row + 1); }
    function edgeKey(a, b) { const x = String(a).toLowerCase(), y = String(b).toLowerCase(); return [x, y].sort().join('|'); }
    /** Parse "a1", "t22" etc. to [col, row]. */
    function coordToColRow(coord) {
      const s = String(coord).toLowerCase();
      const match = s.match(/^([a-z]+)(\d+)$/);
      if (!match) return null;
      let col = 0;
      for (let i = 0; i < match[1].length; i++) col = 26 * col + (match[1].charCodeAt(i) - 97);
      const row = parseInt(match[2], 10) - 1;
      return [col, row];
    }

    function syncDeploymentZoneState(mapId) {
      const z = fullDeploymentZonesData?.maps?.[mapId];
      deploymentZoneState.red = (z?.red || []).map(s => String(s).toLowerCase());
      deploymentZoneState.blue = (z?.blue || []).map(s => String(s).toLowerCase());
    }

    function syncMissionTokenState(mapId) {
      const t = fullMapTokensData?.maps?.[mapId];
      missionTokenState.terminals = (t?.terminals || []).map(s => String(s).toLowerCase());
      missionTokenState.missionA = { launchPanels: (t?.missionA?.launchPanels || []).map(s => String(s).toLowerCase()) };
      missionTokenState.missionB = { contraband: (t?.missionB?.contraband || t?.missionB?.crates || []).map(s => String(s).toLowerCase()) };
      missionTokenState.doors = (t?.doors || []).map((pair) => [String(pair[0]).toLowerCase(), String(pair[1]).toLowerCase()]);
      missionTokenState.namedAreas = Array.isArray(t?.namedAreas) && t.namedAreas.length
        ? t.namedAreas.map((a, i) => ({ id: i, name: a.name || 'Area ' + (i + 1), cells: (a.cells || []).map(s => String(s).toLowerCase()) }))
        : [{ id: 0, name: 'Area 1', cells: [] }];
      updateNamedAreaSelect();
    }

    function getMissionVariant() { return (document.querySelector('input[name="missionVariant"]:checked') || {}).value || 'a'; }

    function updateMissionNameInputs(mapId) {
      const mc = fullMissionCardsData?.maps?.[mapId];
      missionANameValue = (mc?.a?.name != null ? mc.a.name : '') || '';
      missionBNameValue = (mc?.b?.name != null ? mc.b.name : '') || '';
      missionATokenLabel = (mc?.a?.tokenLabel != null ? mc.a.tokenLabel : '') || '';
      missionBTokenLabel = (mc?.b?.tokenLabel != null ? mc.b.tokenLabel : '') || '';
      missionASetup = (mc?.a?.setup != null ? mc.a.setup : '') || '';
      missionBSetup = (mc?.b?.setup != null ? mc.b.setup : '') || '';
      missionAStartOfRound = (mc?.a?.startOfRound != null ? mc.a.startOfRound : '') || '';
      missionBStartOfRound = (mc?.b?.startOfRound != null ? mc.b.startOfRound : '') || '';
      missionAEndOfRound = (mc?.a?.endOfRound != null ? mc.a.endOfRound : '') || '';
      missionBEndOfRound = (mc?.b?.endOfRound != null ? mc.b.endOfRound : '') || '';
      const variant = getMissionVariant();
      const input = document.getElementById('missionNameInput');
      if (input) input.value = variant === 'b' ? missionBNameValue : missionANameValue;
      const tokenLabelEl = document.getElementById('missionTokenLabelInput');
      if (tokenLabelEl) tokenLabelEl.value = variant === 'b' ? missionBTokenLabel : missionATokenLabel;
      const setupEl = document.getElementById('missionSetupInput');
      const startEl = document.getElementById('missionStartOfRoundInput');
      const endEl = document.getElementById('missionEndOfRoundInput');
      if (setupEl) setupEl.value = variant === 'b' ? missionBSetup : missionASetup;
      if (startEl) startEl.value = variant === 'b' ? missionBStartOfRound : missionAStartOfRound;
      if (endEl) endEl.value = variant === 'b' ? missionBEndOfRound : missionAEndOfRound;
    }

    function syncMissionNameFromInput() {
      const variant = getMissionVariant();
      const input = document.getElementById('missionNameInput');
      const v = (input && input.value != null ? input.value : '').trim();
      if (variant === 'b') missionBNameValue = v; else missionANameValue = v;
    }
    function syncMissionTokenLabelFromInput() {
      const variant = getMissionVariant();
      const input = document.getElementById('missionTokenLabelInput');
      const v = (input && input.value != null ? input.value : '').trim();
      if (variant === 'b') missionBTokenLabel = v; else missionATokenLabel = v;
    }

    function syncMissionTextFromInputs() {
      const variant = getMissionVariant();
      const setupEl = document.getElementById('missionSetupInput');
      const startEl = document.getElementById('missionStartOfRoundInput');
      const endEl = document.getElementById('missionEndOfRoundInput');
      const setup = (setupEl && setupEl.value != null ? setupEl.value : '').trim();
      const start = (startEl && startEl.value != null ? startEl.value : '').trim();
      const end = (endEl && endEl.value != null ? endEl.value : '').trim();
      if (variant === 'b') {
        missionBSetup = setup;
        missionBStartOfRound = start;
        missionBEndOfRound = end;
      } else {
        missionASetup = setup;
        missionAStartOfRound = start;
        missionAEndOfRound = end;
      }
    }

    function applyMissionVariantSwitch() {
      // Radio has already changed to the new variant; current field values belong to the variant we're leaving.
      const newVariant = getMissionVariant();
      const leavingVariant = newVariant === 'b' ? 'a' : 'b';
      const nameInput = document.getElementById('missionNameInput');
      const tokenLabelEl = document.getElementById('missionTokenLabelInput');
      const setupEl = document.getElementById('missionSetupInput');
      const startEl = document.getElementById('missionStartOfRoundInput');
      const endEl = document.getElementById('missionEndOfRoundInput');
      if (leavingVariant === 'a') {
        missionANameValue = (nameInput && nameInput.value != null ? nameInput.value : '').trim();
        missionATokenLabel = (tokenLabelEl && tokenLabelEl.value != null ? tokenLabelEl.value : '').trim();
        missionASetup = (setupEl && setupEl.value != null ? setupEl.value : '').trim();
        missionAStartOfRound = (startEl && startEl.value != null ? startEl.value : '').trim();
        missionAEndOfRound = (endEl && endEl.value != null ? endEl.value : '').trim();
      } else {
        missionBNameValue = (nameInput && nameInput.value != null ? nameInput.value : '').trim();
        missionBTokenLabel = (tokenLabelEl && tokenLabelEl.value != null ? tokenLabelEl.value : '').trim();
        missionBSetup = (setupEl && setupEl.value != null ? setupEl.value : '').trim();
        missionBStartOfRound = (startEl && startEl.value != null ? startEl.value : '').trim();
        missionBEndOfRound = (endEl && endEl.value != null ? endEl.value : '').trim();
      }
      if (nameInput) nameInput.value = newVariant === 'b' ? missionBNameValue : missionANameValue;
      if (tokenLabelEl) tokenLabelEl.value = newVariant === 'b' ? missionBTokenLabel : missionATokenLabel;
      if (setupEl) setupEl.value = newVariant === 'b' ? missionBSetup : missionASetup;
      if (startEl) startEl.value = newVariant === 'b' ? missionBStartOfRound : missionAStartOfRound;
      if (endEl) endEl.value = newVariant === 'b' ? missionBEndOfRound : missionAEndOfRound;
      draw();
    }

    function updateNamedAreaSelect() {
      const sel = document.getElementById('namedAreaSelect');
      if (!sel) return;
      const current = sel.value;
      sel.innerHTML = missionTokenState.namedAreas.map((a, i) => '<option value="' + i + '">' + (a.name || 'Area ' + (i + 1)) + '</option>').join('');
      if (current !== '' && missionTokenState.namedAreas[parseInt(current, 10)]) sel.value = current;
      else sel.value = '0';
      const idx = parseInt(sel.value, 10);
      const area = missionTokenState.namedAreas[idx];
      const nameEl = document.getElementById('namedAreaName');
      if (nameEl && area) nameEl.value = area.name || '';
      updateNamedAreaList();
    }

    function updateNamedAreaList() {
      const listEl = document.getElementById('namedAreaList');
      if (!listEl) return;
      const canDelete = missionTokenState.namedAreas.length > 1;
      listEl.innerHTML = missionTokenState.namedAreas.map((a, i) => {
        const name = (a.name || 'Area ' + (i + 1)).trim() || 'Area ' + (i + 1);
        const color = AREA_COLORS[i % AREA_COLORS.length];
        const deleteBtn = canDelete ? '<button type="button" class="area-delete-btn" data-area-index="' + i + '" title="Delete this area" aria-label="Delete area">×</button>' : '';
        return '<div class="area-item"><span class="area-swatch" style="background:' + color + '"></span><span class="area-label">Area ' + (i + 1) + ': ' + escapeHtml(name) + '</span>' + deleteBtn + '</div>';
      }).join('');
    }

    function removeNamedAreaAtIndex(index) {
      if (missionTokenState.namedAreas.length <= 1) return;
      const sel = document.getElementById('namedAreaSelect');
      const currentIdx = sel ? parseInt(sel.value, 10) : 0;
      missionTokenState.namedAreas.splice(index, 1);
      missionTokenState.namedAreas.forEach((a, i) => { a.id = i; });
      updateNamedAreaSelect();
      if (currentIdx >= missionTokenState.namedAreas.length) {
        if (sel) sel.value = String(Math.max(0, missionTokenState.namedAreas.length - 1));
      } else if (currentIdx > index) {
        if (sel) sel.value = String(currentIdx - 1);
      } else if (currentIdx === index) {
        if (sel) sel.value = String(Math.min(currentIdx, missionTokenState.namedAreas.length - 1));
      }
      const nameEl = document.getElementById('namedAreaName');
      const area = missionTokenState.namedAreas[parseInt(sel?.value || '0', 10)];
      if (nameEl && area) nameEl.value = area.name || '';
      updateNamedAreaList();
      draw();
    }

    function escapeHtml(s) {
      const div = document.createElement('div');
      div.textContent = s;
      return div.innerHTML;
    }

    /** Switch to editing the given map id: load its data from fullMapData if present, else empty. */
    function switchToMap(id) {
      syncDeploymentZoneState(id);
      syncMissionTokenState(id);
      updateMissionNameInputs(id);
      const mapData = fullMapData?.maps?.[id];
      const name = ALL_MAPS.find(m => m.id === id)?.name || id;
      if (mapData) {
        loadMapIntoState(mapData);
        if (numCols === 0 && numRows === 0) initGridFromSpaces();
        document.getElementById('status').textContent = 'Editing: ' + name + ' (' + (mapData.spaces || []).length + ' spaces).';
      } else {
        state = { spaces: [], adjacency: {}, terrain: {}, blocking: [], impassableEdges: [], movementBlockingEdges: [], offMap: [], exterior: {}, playReady: true };
        numCols = 0;
        numRows = 0;
        overlay.width = 0;
        overlay.height = 0;
        overlay.style.width = '0px';
        overlay.style.height = '0px';
        document.getElementById('status').textContent = name + ' — Load map-spaces.json or Load map image to start.';
      }
    }

    function loadMapIntoState(mapData) {
      const loadedSpaces = new Set((mapData.spaces || []).map(s => String(s).toLowerCase()));
      const normEdge = (e) => (Array.isArray(e) && e.length >= 2 ? [String(e[0]).toLowerCase(), String(e[1]).toLowerCase()] : e);
      state = {
        spaces: mapData.spaces || [],
        adjacency: mapData.adjacency || {},
        terrain: mapData.terrain || {},
        blocking: mapData.blocking || [],
        impassableEdges: (mapData.impassableEdges || []).map(normEdge),
        movementBlockingEdges: (mapData.movementBlockingEdges || []).map(normEdge),
        offMap: [],
        exterior: mapData.exterior || {},
        playReady: mapData.playReady !== false
      };
      if (numCols > 0 && numRows > 0) {
        const fullGrid = [];
        for (let r = 0; r < numRows; r++) for (let c = 0; c < numCols; c++) fullGrid.push(coordKey(c, r));
        state.offMap = fullGrid.filter(k => !loadedSpaces.has(k));
      }
      draw();
    }

    /** Build grid size and overlay from state.spaces when no image is loaded. */
    function initGridFromSpaces() {
      const positions = (state.spaces || []).map(c => coordToColRow(c)).filter(Boolean);
      if (positions.length === 0) return;
      const maxCol = Math.max(...positions.map(p => p[0]));
      const maxRow = Math.max(...positions.map(p => p[1]));
      numCols = maxCol + 1;
      numRows = maxRow + 1;
      const loadedSet = new Set((state.spaces || []).map(s => String(s).toLowerCase()));
      const fullGrid = [];
      for (let r = 0; r < numRows; r++) for (let c = 0; c < numCols; c++) fullGrid.push(coordKey(c, r));
      state.offMap = fullGrid.filter(k => !loadedSet.has(k));
      const totalW = x0 * 2 + numCols * dx;
      const totalH = y0 * 2 + numRows * dy;
      scale = Math.min(1, 1200 / totalW, 700 / totalH);
      const sw = Math.round(totalW * scale), sh = Math.round(totalH * scale);
      overlay.width = sw;
      overlay.height = sh;
      overlay.style.width = sw + 'px';
      overlay.style.height = sh + 'px';
      draw();
    }

    function init() {
      const w = img.naturalWidth, h = img.naturalHeight;
      if (!w || !h) { document.getElementById('status').textContent = 'Map image empty.'; return; }
      scale = Math.min(1, 1200 / w);
      const sw = Math.round(w * scale), sh = Math.round(h * scale);
      overlay.width = sw; overlay.height = sh;
      overlay.style.width = sw + 'px'; overlay.style.height = sh + 'px';
      numCols = Math.floor((sw - x0 * scale) / (dx * scale));
      numRows = Math.floor((sh - y0 * scale) / (dy * scale));
      if (state.spaces.length === 0) {
        for (let r = 0; r < numRows; r++) for (let c = 0; c < numCols; c++) {
          const k = coordKey(c, r);
          state.spaces.push(k);
          if (!state.terrain[k]) state.terrain[k] = 'normal';
          if (!state.adjacency[k]) {
            const n = [];
            if (c > 0) n.push(coordKey(c-1, r));
            if (c < numCols-1) n.push(coordKey(c+1, r));
            if (r > 0) n.push(coordKey(c, r-1));
            if (r < numRows-1) n.push(coordKey(c, r+1));
            state.adjacency[k] = n;
          }
        }
      }
      document.getElementById('status').textContent = 'Map loaded. Click cells (terrain) or edges (walls).';
      draw();
    }

    function draw() {
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      const sdx = dx * scale, sdy = dy * scale, sx0 = x0 * scale, sy0 = y0 * scale;
      const impSet = new Set((state.impassableEdges || []).map(e => edgeKey(e[0], e[1])));
      const dotSet = new Set((state.movementBlockingEdges || []).map(e => edgeKey(e[0], e[1])));
      const offSet = new Set((state.offMap || []).map(s => String(s).toLowerCase()));
      for (let r = 0; r < numRows; r++) for (let c = 0; c < numCols; c++) {
        const k = coordKey(c, r), x = sx0 + c * sdx, y = sy0 + r * sdy;
        if (offSet.has(k)) {
          ctx.fillStyle = 'rgba(80,80,80,0.75)';
          ctx.fillRect(x, y, sdx, sdy);
          if (deploymentZoneState.red.includes(k)) { ctx.fillStyle = 'rgba(220,53,69,0.55)'; ctx.fillRect(x, y, sdx, sdy); }
          else if (deploymentZoneState.blue.includes(k)) { ctx.fillStyle = 'rgba(13,110,253,0.55)'; ctx.fillRect(x, y, sdx, sdy); }
          ctx.strokeStyle = 'rgba(255,100,100,0.5)';
          ctx.strokeRect(x, y, sdx, sdy);
        } else {
          const ter = state.terrain[k] || 'normal';
          if (ter === 'difficult') { ctx.fillStyle = 'rgba(100,149,237,0.55)'; ctx.fillRect(x, y, sdx, sdy); }
          else if (ter === 'blocking') { ctx.fillStyle = 'rgba(220,53,69,0.65)'; ctx.fillRect(x, y, sdx, sdy); }
          if (state.exterior && state.exterior[k]) { ctx.fillStyle = 'rgba(50,205,50,0.5)'; ctx.fillRect(x, y, sdx, sdy); }
          if (deploymentZoneState.red.includes(k)) { ctx.fillStyle = 'rgba(220,53,69,0.5)'; ctx.fillRect(x, y, sdx, sdy); }
          else if (deploymentZoneState.blue.includes(k)) { ctx.fillStyle = 'rgba(13,110,253,0.5)'; ctx.fillRect(x, y, sdx, sdy); }
          ctx.strokeStyle = 'rgba(255,255,255,0.25)'; ctx.strokeRect(x, y, sdx, sdy);
        }
        for (const [dc, dr, dir] of [[0,-1,'n'],[1,0,'e'],[0,1,'s'],[-1,0,'w']]) {
          const nk = coordKey(c+dc, r+dr);
          const ek = edgeKey(k, nk);
          if (impSet.has(ek)) {
            ctx.fillStyle = 'rgba(255,255,0,0.8)';
            if (dir === 'n') ctx.fillRect(x, y, sdx, 5);
            else if (dir === 's') ctx.fillRect(x, y+sdy-5, sdx, 5);
            else if (dir === 'e') ctx.fillRect(x+sdx-5, y, 5, sdy);
            else ctx.fillRect(x, y, 5, sdy);
          } else if (dotSet.has(ek)) {
            ctx.fillStyle = 'rgba(255,100,100,0.7)';
            if (dir === 'n') ctx.fillRect(x, y, sdx, 4);
            else if (dir === 's') ctx.fillRect(x, y+sdy-4, sdx, 4);
            else if (dir === 'e') ctx.fillRect(x+sdx-4, y, 4, sdy);
            else ctx.fillRect(x, y, 4, sdy);
          }
        }
      }
      // Mission overlay: show only the selected mission's tokens (Mission A or B); terminals, doors, named areas shown for both
      const variant = getMissionVariant();
      const onMapSet = new Set((state.spaces || []).filter(s => !(new Set((state.offMap || []).map(x => String(x).toLowerCase()))).has(String(s).toLowerCase())).map(s => String(s).toLowerCase()));
      const termSet = new Set(missionTokenState.terminals.map(s => String(s).toLowerCase()));
      const aSet = new Set(missionTokenState.missionA.launchPanels.map(s => String(s).toLowerCase()));
      const bSet = new Set(missionTokenState.missionB.contraband.map(s => String(s).toLowerCase()));
      for (let r = 0; r < numRows; r++) for (let c = 0; c < numCols; c++) {
        const k = coordKey(c, r), x = sx0 + c * sdx, y = sy0 + r * sdy;
        if (!onMapSet.has(k)) continue;
        if (termSet.has(k)) drawTokenAt(ctx, tokenImgTerminals, 'square', 'rgba(79,195,247,0.65)', x, y, sdx, sdy);
        if (variant === 'a' && aSet.has(k)) drawTokenAt(ctx, tokenImgMissionA, 'circle', 'rgba(129,199,132,0.65)', x, y, sdx, sdy, (missionATokenLabel || '').trim() || 'Panel');
        if (variant === 'b' && bSet.has(k)) drawTokenAt(ctx, tokenImgMissionB, 'square', 'rgba(255,183,77,0.7)', x, y, sdx, sdy, (missionBTokenLabel || '').trim() || 'Contraband');
        missionTokenState.namedAreas.forEach((area, areaIdx) => {
          const areaSet = new Set((area.cells || []).map(s => String(s).toLowerCase()));
          if (areaSet.has(k)) {
            ctx.fillStyle = AREA_COLORS[areaIdx % AREA_COLORS.length];
            ctx.fillRect(x, y, sdx, sdy);
          }
        });
      }
      missionTokenState.namedAreas.forEach((area, areaIdx) => {
        const areaSet = new Set((area.cells || []).map(s => String(s).toLowerCase()));
        const borderColor = AREA_BORDER_COLORS[areaIdx % AREA_BORDER_COLORS.length];
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 3;
        for (const k of area.cells || []) {
          const cr = coordToColRow(k);
          if (!cr) continue;
          const [c, r] = cr;
          const x = sx0 + c * sdx, y = sy0 + r * sdy;
          for (const [dc, dr, side] of [[0,-1,'n'],[1,0,'e'],[0,1,'s'],[-1,0,'w']]) {
            const nk = coordKey(c+dc, r+dr);
            if (!areaSet.has(nk)) {
              if (side === 'n') ctx.fillRect(x, y, sdx, 4);
              else if (side === 's') ctx.fillRect(x, y + sdy - 4, sdx, 4);
              else if (side === 'e') ctx.fillRect(x + sdx - 4, y, 4, sdy);
              else ctx.fillRect(x, y, 4, sdy);
            }
          }
        }
        ctx.lineWidth = 1;
        // Label: area name at dead center of the area
        const cells = area.cells || [];
        if (cells.length > 0) {
          let sumX = 0, sumY = 0, n = 0;
          for (const coord of cells) {
            const cr = coordToColRow(coord);
            if (!cr) continue;
            const [c, r] = cr;
            sumX += sx0 + (c + 0.5) * sdx;
            sumY += sy0 + (r + 0.5) * sdy;
            n++;
          }
          if (n > 0) {
            const cx = sumX / n, cy = sumY / n;
            const label = (area.name || 'Area ' + (areaIdx + 1)).trim() || 'Area ' + (areaIdx + 1);
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.strokeStyle = 'rgba(0,0,0,0.9)';
            ctx.lineWidth = 3;
            ctx.strokeText(label, cx, cy);
            ctx.fillStyle = '#fff';
            ctx.fillText(label, cx, cy);
            ctx.lineWidth = 1;
          }
        }
      });
      for (const [a, b] of missionTokenState.doors) {
        const pa = coordToColRow(a), pb = coordToColRow(b);
        if (!pa || !pb) continue;
        const [c1, r1] = pa, [c2, r2] = pb;
        let x1, y1, x2, y2;
        if (r1 === r2 && c2 === c1 + 1) {
          x1 = x2 = sx0 + (c1 + 1) * sdx; y1 = sy0 + r1 * sdy; y2 = sy0 + (r1 + 1) * sdy;
        } else if (r1 === r2 && c2 === c1 - 1) {
          x1 = x2 = sx0 + c1 * sdx; y1 = sy0 + r1 * sdy; y2 = sy0 + (r1 + 1) * sdy;
        } else if (c1 === c2 && r2 === r1 + 1) {
          y1 = y2 = sy0 + (r1 + 1) * sdy; x1 = sx0 + c1 * sdx; x2 = sx0 + (c1 + 1) * sdx;
        } else if (c1 === c2 && r2 === r1 - 1) {
          y1 = y2 = sy0 + r1 * sdy; x1 = sx0 + c1 * sdx; x2 = sx0 + (c1 + 1) * sdx;
        } else {
          x1 = sx0 + (c1 + 0.5) * sdx; y1 = sy0 + (r1 + 0.5) * sdy;
          x2 = sx0 + (c2 + 0.5) * sdx; y2 = sy0 + (r2 + 0.5) * sdy;
        }
        ctx.strokeStyle = 'rgba(255,200,0,0.95)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.lineWidth = 1;
      }
    }

    function getCellInfo(e) {
      const r = overlay.getBoundingClientRect();
      const px = (e.clientX - r.left) * (overlay.width / r.width);
      const py = (e.clientY - r.top) * (overlay.height / r.height);
      const sdx = dx * scale, sdy = dy * scale, sx0 = x0 * scale, sy0 = y0 * scale;
      const col = Math.floor((px - sx0) / sdx), row = Math.floor((py - sy0) / sdy);
      if (col < 0 || row < 0 || col >= numCols || row >= numRows) return null;
      const lx = (px - sx0) % sdx, ly = (py - sy0) % sdy;
      const edge = (lx < 6 ? 'w' : lx > sdx - 6 ? 'e' : ly < 6 ? 'n' : ly > sdy - 6 ? 's' : null);
      return { col, row, edge, coord: coordKey(col, row) };
    }

    let dragState = null;

    function applyOffMap(info, paintOffMap) {
      const off = new Set((state.offMap || []).map(s => String(s).toLowerCase()));
      if (paintOffMap) off.add(info.coord);
      else off.delete(info.coord);
      state.offMap = [...off];
    }

    function applyExterior(info, paintExterior) {
      if (new Set((state.offMap || []).map(s => String(s).toLowerCase())).has(info.coord)) return;
      state.exterior = state.exterior || {};
      state.exterior[info.coord] = !!paintExterior;
    }

    function applyDeploymentZone(info, paint) {
      const k = String(info.coord).toLowerCase();
      deploymentZoneState.red = deploymentZoneState.red.filter(c => c !== k);
      deploymentZoneState.blue = deploymentZoneState.blue.filter(c => c !== k);
      if (paint === 'red') deploymentZoneState.red.push(k);
      else if (paint === 'blue') deploymentZoneState.blue.push(k);
    }
    /** Next deployment zone state for a cell: none → red → blue → none. Returns 'red' | 'blue' | 'clear'. */
    function getDeploymentZoneNext(coord) {
      const k = String(coord).toLowerCase();
      if (deploymentZoneState.red.includes(k)) return 'blue';
      if (deploymentZoneState.blue.includes(k)) return 'clear';
      return 'red';
    }

    function applyCellAction(info, mode, paintOffMap) {
      if (mode === 'offmap') {
        applyOffMap(info, paintOffMap);
      } else if (mode === 'exterior' && typeof paintOffMap === 'boolean') {
        applyExterior(info, paintOffMap);
      } else if (mode === 'terrain') {
        if (new Set((state.offMap || []).map(s => String(s).toLowerCase())).has(info.coord)) return;
        const next = { normal: 'difficult', difficult: 'blocking', blocking: 'normal' };
        state.terrain[info.coord] = next[state.terrain[info.coord] || 'normal'];
        state.blocking = state.spaces.filter(s => state.terrain[s] === 'blocking' && !(state.offMap || []).includes(s));
      } else if (mode === 'exterior') {
        if (new Set((state.offMap || []).map(s => String(s).toLowerCase())).has(info.coord)) return;
        state.exterior = state.exterior || {};
        state.exterior[info.coord] = !state.exterior[info.coord];
      } else if (mode === 'deploymentzone' && typeof paintOffMap === 'string') {
        applyDeploymentZone(info, paintOffMap);
      } else if (mode === 'edge' && info.edge) {
        const nc = info.edge === 'e' ? info.col + 1 : info.edge === 'w' ? info.col - 1 : info.col;
        const nr = info.edge === 's' ? info.row + 1 : info.edge === 'n' ? info.row - 1 : info.row;
        if (nc >= 0 && nc < numCols && nr >= 0 && nr < numRows) {
          const nk = coordKey(nc, nr);
          const ek = edgeKey(info.coord, nk);
          const impIdx = state.impassableEdges.findIndex(([a,b]) => edgeKey(a,b) === ek);
          const dotIdx = (state.movementBlockingEdges || []).findIndex(([a,b]) => edgeKey(a,b) === ek);
          const removeFromAdj = () => {
            state.adjacency[info.coord] = (state.adjacency[info.coord] || []).filter(x => x !== nk);
            state.adjacency[nk] = (state.adjacency[nk] || []).filter(x => x !== info.coord);
          };
          const addToAdj = () => {
            if (!(state.adjacency[info.coord] || []).includes(nk)) state.adjacency[info.coord].push(nk);
            if (!(state.adjacency[nk] || []).includes(info.coord)) state.adjacency[nk].push(info.coord);
          };
          if (impIdx >= 0) {
            state.impassableEdges.splice(impIdx, 1);
            state.movementBlockingEdges = state.movementBlockingEdges || [];
            state.movementBlockingEdges.push([info.coord, nk]);
            removeFromAdj();
          } else if (dotIdx >= 0) {
            state.movementBlockingEdges.splice(dotIdx, 1);
            addToAdj();
          } else {
            state.impassableEdges.push([info.coord, nk]);
            removeFromAdj();
          }
        }
      }
    }

    /** Single tool mode: map tools (offmap, terrain, edge, exterior, deploymentzone) or mission tools (terminal, missionTokens, doors, namedarea). Only one can be selected. */
    function getMode() { return (document.querySelector('input[name="mode"]:checked') || {}).value || 'offmap'; }

    document.querySelectorAll('input[name="missionVariant"]').forEach((el) => {
      el.onchange = () => applyMissionVariantSwitch();
    });
    const missionNameInput = document.getElementById('missionNameInput');
    if (missionNameInput) {
      missionNameInput.oninput = missionNameInput.onchange = missionNameInput.onblur = () => syncMissionNameFromInput();
    }
    const missionTokenLabelInput = document.getElementById('missionTokenLabelInput');
    if (missionTokenLabelInput) {
      missionTokenLabelInput.oninput = missionTokenLabelInput.onchange = missionTokenLabelInput.onblur = () => syncMissionTokenLabelFromInput();
    }
    ['missionSetupInput', 'missionStartOfRoundInput', 'missionEndOfRoundInput'].forEach((id) => {
      const el = document.getElementById(id);
      if (el) el.oninput = el.onchange = el.onblur = () => syncMissionTextFromInputs();
    });

    document.getElementById('addNamedAreaBtn').onclick = () => {
      const n = missionTokenState.namedAreas.length;
      missionTokenState.namedAreas.push({ id: n, name: 'Area ' + (n + 1), cells: [] });
      updateNamedAreaSelect();
      document.getElementById('namedAreaSelect').value = String(n);
      const nameEl = document.getElementById('namedAreaName');
      if (nameEl) nameEl.value = 'Area ' + (n + 1);
    };

    const namedAreaListEl = document.getElementById('namedAreaList');
    if (namedAreaListEl) {
      namedAreaListEl.addEventListener('click', (e) => {
        const btn = e.target.closest('.area-delete-btn');
        if (btn) {
          e.preventDefault();
          const idx = parseInt(btn.getAttribute('data-area-index'), 10);
          if (!isNaN(idx)) removeNamedAreaAtIndex(idx);
        }
      });
    }

    document.getElementById('namedAreaSelect').onchange = () => {
      const idx = parseInt(document.getElementById('namedAreaSelect').value, 10);
      const area = missionTokenState.namedAreas[idx];
      const nameEl = document.getElementById('namedAreaName');
      if (nameEl && area) nameEl.value = area.name || '';
    };
    document.getElementById('namedAreaName').onchange = document.getElementById('namedAreaName').onblur = () => {
      const idx = parseInt(document.getElementById('namedAreaSelect').value, 10);
      const area = missionTokenState.namedAreas[idx];
      const nameEl = document.getElementById('namedAreaName');
      if (area && nameEl) {
        area.name = (nameEl.value || '').trim() || area.name || 'Area ' + (idx + 1);
        updateNamedAreaSelect();
        draw();
      }
    };

    overlay.onmousedown = (e) => {
      if (e.button !== 0) return;
      e.preventDefault();
      const info = getCellInfo(e);
      if (!info) return;
      const mode = getMode();
      const isMissionTool = mode === 'terminal' || mode === 'missionTokens' || mode === 'doors' || mode === 'namedarea';
      if (isMissionTool) {
        const offSet = new Set((state.offMap || []).map(s => String(s).toLowerCase()));
        const onMap = new Set((state.spaces || []).map(s => String(s).toLowerCase()).filter(k => !offSet.has(k)));
        if (mode === 'terminal' && onMap.has(info.coord)) {
          const k = String(info.coord).toLowerCase();
          const idx = missionTokenState.terminals.indexOf(k);
          if (idx >= 0) missionTokenState.terminals.splice(idx, 1);
          else missionTokenState.terminals.push(k);
          dragState = { missionMode: mode, paintAdd: missionTokenState.terminals.includes(k), lastCoord: info.coord };
        } else if (mode === 'missionTokens' && onMap.has(info.coord)) {
          const k = String(info.coord).toLowerCase();
          const variant = getMissionVariant();
          const arr = variant === 'b' ? missionTokenState.missionB.contraband : missionTokenState.missionA.launchPanels;
          const idx = arr.indexOf(k);
          if (idx >= 0) arr.splice(idx, 1);
          else arr.push(k);
          dragState = { missionMode: mode, paintAdd: arr.includes(k), lastCoord: info.coord };
        } else if (mode === 'doors' && info.edge) {
          const nc = info.edge === 'e' ? info.col + 1 : info.edge === 'w' ? info.col - 1 : info.col;
          const nr = info.edge === 's' ? info.row + 1 : info.edge === 'n' ? info.row - 1 : info.row;
          if (nc >= 0 && nc < numCols && nr >= 0 && nr < numRows) {
            const nk = coordKey(nc, nr);
            const ek = edgeKey(info.coord, nk);
            const idx = missionTokenState.doors.findIndex(([a, b]) => edgeKey(a, b) === ek);
            if (idx >= 0) missionTokenState.doors.splice(idx, 1);
            else missionTokenState.doors.push([String(info.coord).toLowerCase(), String(nk).toLowerCase()]);
          }
          dragState = null;
        } else if (mode === 'namedarea' && onMap.has(info.coord)) {
          const k = String(info.coord).toLowerCase();
          const idx = parseInt(document.getElementById('namedAreaSelect').value, 10);
          const area = missionTokenState.namedAreas[idx];
          if (area) {
            const ci = area.cells.indexOf(k);
            const paintAdd = ci < 0;
            if (ci >= 0) area.cells.splice(ci, 1);
            else area.cells.push(k);
            dragState = { missionMode: mode, paintAdd, lastCoord: info.coord, areaIndex: idx };
          }
        }
        draw();
        return;
      }
      if (mode === 'offmap') {
        const off = new Set((state.offMap || []).map(s => String(s).toLowerCase()));
        const paintOffMap = !off.has(info.coord);
        applyOffMap(info, paintOffMap);
        dragState = { mode, paintOffMap, lastCoord: info.coord };
        draw();
      } else if (mode === 'exterior') {
        const paintExterior = !(state.exterior && state.exterior[info.coord]);
        applyExterior(info, paintExterior);
        dragState = { mode, paintOffMap: paintExterior, lastCoord: info.coord };
        draw();
      } else if (mode === 'deploymentzone') {
        const next = getDeploymentZoneNext(info.coord);
        applyDeploymentZone(info, next);
        dragState = { mode, paintOffMap: next, lastCoord: info.coord };
        draw();
      } else {
        applyCellAction(info, mode, null);
        draw();
      }
    };

    overlay.onmousemove = (e) => {
      if (!dragState) return;
      const info = getCellInfo(e);
      if (!info || info.coord === dragState.lastCoord) return;
      if (dragState.missionMode) {
        const offSet = new Set((state.offMap || []).map(s => String(s).toLowerCase()));
        const onMap = new Set((state.spaces || []).map(s => String(s).toLowerCase()).filter(k => !offSet.has(k)));
        if (!onMap.has(info.coord)) return;
        const k = String(info.coord).toLowerCase();
        if (dragState.missionMode === 'terminal') {
          const has = missionTokenState.terminals.includes(k);
          if ((dragState.paintAdd && !has) || (!dragState.paintAdd && has)) {
            if (has) missionTokenState.terminals.splice(missionTokenState.terminals.indexOf(k), 1);
            else missionTokenState.terminals.push(k);
          }
        } else if (dragState.missionMode === 'missionTokens') {
          const variant = getMissionVariant();
          const arr = variant === 'b' ? missionTokenState.missionB.contraband : missionTokenState.missionA.launchPanels;
          const has = arr.includes(k);
          if ((dragState.paintAdd && !has) || (!dragState.paintAdd && has)) {
            if (has) arr.splice(arr.indexOf(k), 1);
            else arr.push(k);
          }
        } else if (dragState.missionMode === 'namedarea' && missionTokenState.namedAreas[dragState.areaIndex]) {
          const area = missionTokenState.namedAreas[dragState.areaIndex];
          const has = area.cells.includes(k);
          if ((dragState.paintAdd && !has) || (!dragState.paintAdd && has)) {
            if (has) area.cells.splice(area.cells.indexOf(k), 1);
            else area.cells.push(k);
          }
        }
        dragState.lastCoord = info.coord;
        draw();
        return;
      }
      dragState.lastCoord = info.coord;
      applyCellAction(info, dragState.mode, dragState.paintOffMap);
      draw();
    };

    overlay.onmouseup = overlay.onmouseleave = () => {
      if (dragState) { dragState = null; }
    };

    document.addEventListener('mouseup', () => { if (dragState) dragState = null; });

    function updateInRotationCheckbox() {
      const select = document.getElementById('mapSelect');
      const cb = document.getElementById('inRotationCheckbox');
      if (!select || !cb) return;
      const mapId = select.value || '';
      const inRotation = (fullTournamentRotationData.missionIds || []).some(m => String(m).startsWith(mapId + ':'));
      cb.checked = !!inRotation;
    }

    function updatePlayReadyCheckbox() {
      const cb = document.getElementById('playReadyCheckbox');
      if (cb) cb.checked = state.playReady !== false;
    }

    function applyRotationCheckboxChange(checked) {
      const mapId = document.getElementById('mapSelect').value || '';
      if (!mapId) return;
      const ids = fullTournamentRotationData.missionIds;
      if (checked) {
        const hasVariant = ids.some(m => String(m).startsWith(mapId + ':'));
        if (!hasVariant) ids.push(mapId + ':a');
      } else {
        for (let i = ids.length - 1; i >= 0; i--) {
          if (String(ids[i]).startsWith(mapId + ':')) ids.splice(i, 1);
        }
      }
    }

    const LAST_MAP_KEY = 'map-tool-last-map';

    // Populate map dropdown with every map on load
    (function initMapSelect() {
      const select = document.getElementById('mapSelect');
      ALL_MAPS.forEach(m => select.appendChild(new Option(m.name, m.id)));
      const savedId = (typeof localStorage !== 'undefined' && localStorage.getItem(LAST_MAP_KEY)) || '';
      const validId = ALL_MAPS.some(m => m.id === savedId) ? savedId : 'mos-eisley-outskirts';
      select.value = validId;
      select.onchange = () => {
        const id = select.value;
        if (id) {
          if (typeof localStorage !== 'undefined') localStorage.setItem(LAST_MAP_KEY, id);
          const path = mapImagePathForUrl(mapImagePaths[id]);
          if (path) img.src = '/' + path;
          switchToMap(id);
          updateInRotationCheckbox();
          updatePlayReadyCheckbox();
        }
      };
      // Always prefer last-selected map (validId from localStorage); only use first-in-file when we have no saved id
      const idToShow = validId;
      select.value = idToShow;
      const pathToShow = mapImagePathForUrl(mapImagePaths[idToShow]);
      if (pathToShow) img.src = '/' + pathToShow;
      switchToMap(idToShow);
      updateInRotationCheckbox();
      updatePlayReadyCheckbox();
      document.getElementById('inRotationCheckbox').onchange = function () {
        applyRotationCheckboxChange(this.checked);
      };
      document.getElementById('playReadyCheckbox').onchange = function () {
        state.playReady = this.checked;
      };
    })();

    function applyLoadedData(data) {
      fullMapData = data;
      const maps = data.maps || {};
      const mapIdsInFile = Object.keys(maps);
      const select = document.getElementById('mapSelect');
      const currentId = select.value;
      const idToShow = maps[currentId] ? currentId : (mapIdsInFile[0] || null);
      if (idToShow) {
        select.value = idToShow;
        switchToMap(idToShow);
        updateInRotationCheckbox();
        updatePlayReadyCheckbox();
        const n = mapIdsInFile.length;
        document.getElementById('status').textContent = 'Loaded ' + n + ' map(s). Editing: ' + (ALL_MAPS.find(m => m.id === idToShow)?.name || idToShow) + '.';
      } else {
        document.getElementById('status').textContent = 'File has no map data. Expected { "maps": { "map-id": { "spaces": [...] } } }.';
      }
    }

    // Auto-load data/map-spaces.json when opened from a static server (if not already injected)
    if (!fullMapData || !fullMapData.maps) {
      fetch('../../data/map-spaces.json').then(r => r.ok ? r.json() : Promise.reject()).then(applyLoadedData).catch(() => {});
    }

    function doSave() {
      const offSet = new Set((state.offMap || []).map(s => String(s).toLowerCase()));
      const onMapSpaces = state.spaces.filter(s => !offSet.has(String(s).toLowerCase()));
      const onMapSet = new Set(onMapSpaces.map(s => String(s).toLowerCase()));
      const adj = {};
      for (const coord of onMapSpaces) {
        const k = String(coord).toLowerCase();
        adj[k] = (state.adjacency[k] || []).filter(n => onMapSet.has(String(n).toLowerCase()));
      }
      const terrain = {};
      for (const k of onMapSpaces) {
        const t = state.terrain[String(k).toLowerCase()];
        if (t && t !== 'normal') terrain[String(k).toLowerCase()] = t;
      }
      const blocking = onMapSpaces.filter(s => state.terrain[String(s).toLowerCase()] === 'blocking');
      const impEdges = (state.impassableEdges || []).filter(([a,b]) => onMapSet.has(String(a).toLowerCase()) || onMapSet.has(String(b).toLowerCase()));
      const movEdges = (state.movementBlockingEdges || []).filter(([a,b]) => onMapSet.has(String(a).toLowerCase()) || onMapSet.has(String(b).toLowerCase()));
      const exterior = {};
      for (const k of onMapSpaces) {
        const key = String(k).toLowerCase();
        if (state.exterior && state.exterior[key]) exterior[key] = true;
      }
      const exportState = { spaces: onMapSpaces, adjacency: adj, terrain, blocking, impassableEdges: impEdges, movementBlockingEdges: movEdges, exterior: Object.keys(exterior).length ? exterior : undefined, playReady: state.playReady !== false };
      const selectedId = document.getElementById('mapSelect').value || 'mos-eisley-outskirts';
      const data = fullMapData && fullMapData.maps
        ? { ...fullMapData, maps: { ...fullMapData.maps, [selectedId]: exportState } }
        : { source: 'extract-map-spaces.html', maps: { [selectedId]: exportState } };
      const zonesData = { source: fullDeploymentZonesData?.source || 'extract-map-spaces.html', maps: { ...(fullDeploymentZonesData?.maps || {}), [selectedId]: { red: [...deploymentZoneState.red], blue: [...deploymentZoneState.blue] } } };
      const tokensPayload = {
        terminals: [...missionTokenState.terminals].sort(),
        missionA: { launchPanels: [...missionTokenState.missionA.launchPanels].sort() },
        missionB: { contraband: [...missionTokenState.missionB.contraband].sort() },
        doors: missionTokenState.doors.map(([a, b]) => [a, b]),
        namedAreas: missionTokenState.namedAreas.map((a) => ({ name: a.name, cells: [...(a.cells || [])].sort() }))
      };
      const tokensData = { source: fullMapTokensData?.source || 'extract-map-spaces.html', maps: { ...(fullMapTokensData?.maps || {}), [selectedId]: tokensPayload } };
      syncMissionNameFromInput();
      syncMissionTokenLabelFromInput();
      syncMissionTextFromInputs();
      const existingMc = fullMissionCardsData?.maps?.[selectedId] || {};
      const missionCardsData = {
        source: fullMissionCardsData?.source || 'extract-map-spaces.html',
        maps: { ...(fullMissionCardsData?.maps || {}), [selectedId]: {
          a: {
            name: (missionANameValue || '').trim() || (existingMc.a?.name || ''),
            tokenLabel: (missionATokenLabel || '').trim() || (existingMc.a?.tokenLabel || ''),
            imagePath: missionCardImagePath(existingMc.a?.imagePath || ''),
            setup: (missionASetup || '').trim(),
            startOfRound: (missionAStartOfRound || '').trim(),
            endOfRound: (missionAEndOfRound || '').trim()
          },
          b: {
            name: (missionBNameValue || '').trim() || (existingMc.b?.name || ''),
            tokenLabel: (missionBTokenLabel || '').trim() || (existingMc.b?.tokenLabel || ''),
            imagePath: missionCardImagePath(existingMc.b?.imagePath || ''),
            setup: (missionBSetup || '').trim(),
            startOfRound: (missionBStartOfRound || '').trim(),
            endOfRound: (missionBEndOfRound || '').trim()
          }
        } }
      };
      const payload = { mapSpaces: data, tournamentRotation: fullTournamentRotationData, deploymentZones: zonesData, mapTokens: tokensData, missionCards: missionCardsData };
      const trySave = (url) => fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
      const urls = [];
      if (typeof location !== 'undefined' && location.origin && location.origin !== 'null') urls.push(location.origin + '/map-tool-save');
      urls.push('http://127.0.0.1:3457/map-tool-save', 'http://localhost:3457/map-tool-save');
      (function attempt(i) {
        if (i >= urls.length) {
          doSaveToFile();
          document.getElementById('status').textContent = 'Server not reachable — your data was downloaded. Click "Save to file" (next to Save) to download again. To have Save write to the project, close this tab and run "npm run map-tool" in the project folder so the tool opens from the server.';
          document.getElementById('saveFallbackWrap').style.display = 'inline';
          return;
        }
        trySave(urls[i]).then((r) => {
          if (!r.ok) return r.text().then((t) => Promise.reject(new Error(t || String(r.status))));
          if (typeof fullMapData === 'object') fullMapData = data;
          fullDeploymentZonesData = zonesData;
          fullMapTokensData = tokensData;
          fullMissionCardsData = missionCardsData;
          try { localStorage.setItem(MISSION_CARDS_STORAGE_KEY, JSON.stringify(missionCardsData)); } catch (e) {}
          document.getElementById('saveFallbackWrap').style.display = 'none';
          const now = new Date();
          const timeStr = now.toLocaleTimeString(undefined, { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
          const inRotation = (fullTournamentRotationData.missionIds || []).some(m => String(m).startsWith(selectedId + ':'));
          const difficultCount = onMapSpaces.filter(s => (state.terrain[String(s).toLowerCase()] || 'normal') === 'difficult').length;
          const blockingCount = (state.blocking || []).length;
          const exteriorCount = Object.keys(state.exterior || {}).length;
          const solidWalls = (state.impassableEdges || []).length;
          const movBlockEdges = (state.movementBlockingEdges || []).length;
          const lines = [
            'Saved at ' + timeStr,
            'Map: ' + selectedId,
            'Map spaces: ' + onMapSpaces.length + ' spaces · In competitive rotation: ' + (inRotation ? 'yes' : 'no') + ' · Play ready: ' + (state.playReady !== false ? 'yes' : 'no'),
            'Terrain: ' + difficultCount + ' difficult, ' + blockingCount + ' blocking, ' + exteriorCount + ' exterior · ' + solidWalls + ' solid walls, ' + movBlockEdges + ' movement-blocking edges',
            'Tournament rotation: ' + (fullTournamentRotationData.missionIds && fullTournamentRotationData.missionIds.length ? fullTournamentRotationData.missionIds.join(', ') : 'none'),
            'Deployment zones: ' + deploymentZoneState.red.length + ' red, ' + deploymentZoneState.blue.length + ' blue',
            'Mission tokens: ' + missionTokenState.terminals.length + ' terminals, ' + (missionTokenState.missionA.launchPanels || []).length + ' A, ' + (missionTokenState.missionB.contraband || []).length + ' B, ' + (missionTokenState.doors || []).length + ' doors',
            'Mission names: A «' + (missionANameValue || '').trim() + '» B «' + (missionBNameValue || '').trim() + '»',
            'Token labels: A «' + (missionATokenLabel || '').trim() + '» B «' + (missionBTokenLabel || '').trim() + '»',
            'Reload this page via the map-tool server to see saved mission names next time.'
          ];
          const statusEl = document.getElementById('status');
          statusEl.innerHTML = lines.join('<br>');
          statusEl.classList.add('saved-flash');
          setTimeout(function () { statusEl.classList.remove('saved-flash'); }, 1200);
        }).catch(() => attempt(i + 1));
      })(0);
    }

    function buildSavePayload() {
      const offSet = new Set((state.offMap || []).map(s => String(s).toLowerCase()));
      const onMapSpaces = state.spaces.filter(s => !offSet.has(String(s).toLowerCase()));
      const onMapSet = new Set(onMapSpaces.map(s => String(s).toLowerCase()));
      const adj = {};
      for (const coord of onMapSpaces) {
        const k = String(coord).toLowerCase();
        adj[k] = (state.adjacency[k] || []).filter(n => onMapSet.has(String(n).toLowerCase()));
      }
      const terrain = {};
      for (const k of onMapSpaces) {
        const t = state.terrain[String(k).toLowerCase()];
        if (t && t !== 'normal') terrain[String(k).toLowerCase()] = t;
      }
      const blocking = onMapSpaces.filter(s => state.terrain[String(s).toLowerCase()] === 'blocking');
      const impEdges = (state.impassableEdges || []).filter(([a,b]) => onMapSet.has(String(a).toLowerCase()) || onMapSet.has(String(b).toLowerCase()));
      const movEdges = (state.movementBlockingEdges || []).filter(([a,b]) => onMapSet.has(String(a).toLowerCase()) || onMapSet.has(String(b).toLowerCase()));
      const exterior = {};
      for (const k of onMapSpaces) {
        const key = String(k).toLowerCase();
        if (state.exterior && state.exterior[key]) exterior[key] = true;
      }
      const exportState = { spaces: onMapSpaces, adjacency: adj, terrain, blocking, impassableEdges: impEdges, movementBlockingEdges: movEdges, exterior: Object.keys(exterior).length ? exterior : undefined, playReady: state.playReady !== false };
      const selectedId = document.getElementById('mapSelect').value || 'mos-eisley-outskirts';
      const data = fullMapData && fullMapData.maps ? { ...fullMapData, maps: { ...fullMapData.maps, [selectedId]: exportState } } : { source: 'extract-map-spaces.html', maps: { [selectedId]: exportState } };
      const zonesData = { source: fullDeploymentZonesData?.source || 'extract-map-spaces.html', maps: { ...(fullDeploymentZonesData?.maps || {}), [selectedId]: { red: [...deploymentZoneState.red], blue: [...deploymentZoneState.blue] } } };
      const tokensPayload = { terminals: [...missionTokenState.terminals].sort(), missionA: { launchPanels: [...missionTokenState.missionA.launchPanels].sort() }, missionB: { contraband: [...missionTokenState.missionB.contraband].sort() }, doors: missionTokenState.doors.map(([a, b]) => [a, b]), namedAreas: missionTokenState.namedAreas.map((a) => ({ name: a.name, cells: [...(a.cells || [])].sort() })) };
      const tokensData = { source: fullMapTokensData?.source || 'extract-map-spaces.html', maps: { ...(fullMapTokensData?.maps || {}), [selectedId]: tokensPayload } };
      return { mapSpaces: data, tournamentRotation: fullTournamentRotationData, deploymentZones: zonesData, mapTokens: tokensData };
    }

    function doSaveToFile() {
      const payload = buildSavePayload();
      syncMissionNameFromInput();
      syncMissionTokenLabelFromInput();
      syncMissionTextFromInputs();
      const selectedId = document.getElementById('mapSelect').value || 'mos-eisley-outskirts';
      const existingMc = fullMissionCardsData?.maps?.[selectedId] || {};
      const missionCards = {
        source: fullMissionCardsData?.source || 'extract-map-spaces.html',
        maps: { ...(fullMissionCardsData?.maps || {}), [selectedId]: {
          a: {
            name: (missionANameValue || '').trim() || (existingMc.a?.name || ''),
            tokenLabel: (missionATokenLabel || '').trim() || (existingMc.a?.tokenLabel || ''),
            imagePath: missionCardImagePath(existingMc.a?.imagePath || ''),
            setup: (missionASetup || '').trim(),
            startOfRound: (missionAStartOfRound || '').trim(),
            endOfRound: (missionAEndOfRound || '').trim()
          },
          b: {
            name: (missionBNameValue || '').trim() || (existingMc.b?.name || ''),
            tokenLabel: (missionBTokenLabel || '').trim() || (existingMc.b?.tokenLabel || ''),
            imagePath: missionCardImagePath(existingMc.b?.imagePath || ''),
            setup: (missionBSetup || '').trim(),
            startOfRound: (missionBStartOfRound || '').trim(),
            endOfRound: (missionBEndOfRound || '').trim()
          }
        } }
      };
      const all = { mapSpaces: payload.mapSpaces, tournamentRotation: payload.tournamentRotation, deploymentZones: payload.deploymentZones, mapTokens: payload.mapTokens, missionCards };
      try { localStorage.setItem(MISSION_CARDS_STORAGE_KEY, JSON.stringify(missionCards)); } catch (e) {}
      const blob = new Blob([JSON.stringify(all, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'map-tool-save-payload.json';
      a.click();
      URL.revokeObjectURL(a.href);
      document.getElementById('status').textContent = 'Downloaded. To apply to project: put the file in the project folder and run: npm run apply-map-tool';
    }

    document.getElementById('downloadDataBtn').onclick = doSaveToFile;

    document.getElementById('saveBtn').onclick = () => doSave();

    img.onload = function () {
      init();
      draw();
    };
    img.onerror = () => {
      document.getElementById('status').textContent = 'Select a map above; grid appears when data is loaded.';
    };
    if (img.complete) { init(); draw(); }
  </script>
</body>
</html>
