<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Map Spaces / Terrain Extractor</title>
  <style>
    body { font-family: sans-serif; padding: 16px; background: #222; color: #eee; }
    .toolbar { margin: 12px 0; }
    button { padding: 8px 16px; margin-right: 8px; cursor: pointer; }
    .container { position: relative; display: inline-block; min-height: 200px; }
    #mapImg { display: block; max-width: 1200px; }
    #overlay { position: absolute; left: 0; top: 0; cursor: crosshair; user-select: none; z-index: 1; }
    #status { margin: 8px 0; color: #9f9; }
    .mode { margin-right: 12px; }
    label { cursor: pointer; }
    #colorKey { margin: 8px 0 12px 0; font-size: 0.85em; color: #bbb; display: flex; flex-wrap: wrap; gap: 10px 16px; align-items: center; }
    #colorKey span { display: inline-flex; align-items: center; gap: 4px; }
    #colorKey .swatch { width: 14px; height: 14px; border-radius: 2px; border: 1px solid rgba(255,255,255,0.3); }
  </style>
</head>
<body>
  <h1>Map Spaces — Terrain & Walls</h1>
  <p id="status">Load map-spaces.json. Off-map: click or drag to exclude/restore cells. Terrain: click to cycle. Edges: click for walls.</p>
  <p style="margin:4px 0 8px 0; font-size:0.9em; color:#999;">Run <code>npm run map-tool</code> then open the URL it prints. To see the map picture under the grid, add the map .gif files to <code>vassal_extracted/images/</code> (e.g. from a Vassal module extract).</p>
  <div id="colorKey" title="Grid overlay legend">
    <span><span class="swatch" style="background:#505050;"></span> Off-map</span>
    <span><span class="swatch" style="background:rgba(100,149,237,0.65);"></span> Difficult terrain</span>
    <span><span class="swatch" style="background:rgba(220,53,69,0.7);"></span> Blocking</span>
    <span><span class="swatch" style="background:rgba(50,205,50,0.6);"></span> Exterior</span>
    <span><span class="swatch" style="background:rgba(220,53,69,0.6);"></span> Red deployment zone</span>
    <span><span class="swatch" style="background:rgba(13,110,253,0.6);"></span> Blue deployment zone</span>
    <span><span class="swatch" style="background:rgba(255,255,0,0.9);"></span> Solid wall</span>
    <span><span class="swatch" style="background:rgba(255,100,100,0.8);"></span> Movement-blocking edge</span>
  </div>
  <div class="toolbar">
    <label>Map: <select id="mapSelect" title="Select which map to configure"></select></label>
    <span class="mode" style="margin-left:8px"><label title="Read-only: at least one mission variant of this map is in data/tournament-rotation.json"><input type="checkbox" id="inRotationCheckbox" disabled> In competitive rotation</label></span>
    <span class="mode"><label><input type="radio" name="mode" value="offmap" checked> Off-map (click to exclude)</label></span>
    <span class="mode"><label><input type="radio" name="mode" value="terrain"> Terrain (normal → difficult → blocking)</label></span>
    <span class="mode"><label><input type="radio" name="mode" value="edge"> Edge (solid wall → dotted → clear)</label></span>
    <span class="mode"><label><input type="radio" name="mode" value="exterior"> Exterior (green = exterior; click or drag to paint/clear)</label></span>
    <span class="mode" id="deploymentZoneWrap"><label><input type="radio" name="mode" value="deploymentzone"> Deployment zone</label> <span id="zonePaintWrap"><button type="button" id="zonePaintRed" title="Paint red zone">Red</button> <button type="button" id="zonePaintBlue" title="Paint blue zone">Blue</button> <button type="button" id="zonePaintClear" title="Clear zone">Clear</button></span></span>
    <button id="saveBtn" style="background:#0a0;color:#fff;font-weight:bold">Save</button>
    <button id="saveZonesBtn" style="background:#06c;color:#fff">Save zones</button>
  </div>
  <div class="container">
    <img id="mapImg" src="maps/Map_Mos Eisley Outskirts.gif" alt="Map">
    <canvas id="overlay"></canvas>
  </div>
  <!-- INJECT_MAP_SPACES -->
  <!-- INJECT_MAP_IMAGE_PATHS -->
  <!-- INJECT_TOURNAMENT_ROTATION -->
  <!-- INJECT_DEPLOYMENT_ZONES -->
  <script>
    const img = document.getElementById('mapImg');
    // If default src is old path without maps/ (e.g. cached HTML), fix it so image loads from images/maps/
    (function () {
      const s = img.getAttribute('src') || '';
      if (s && s.includes('Map_') && !s.includes('maps/') && !s.startsWith('http')) img.setAttribute('src', 'maps/' + s.replace(/^.*[/\\]/, ''));
    })();
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const dx = 50, dy = 50, x0 = 25, y0 = 25;
    let scale = 1, numCols = 0, numRows = 0;
    let state = { spaces: [], adjacency: {}, terrain: {}, blocking: [], impassableEdges: [], movementBlockingEdges: [], offMap: [], exterior: {} };
    /** Full file data from last Load (or injected by map-tool server); used to preserve other maps on Export. */
    let fullMapData = (function () {
      const el = document.getElementById('map-spaces-data');
      if (el && el.textContent) try { return JSON.parse(el.textContent); } catch (e) {}
      return null;
    })();
    /** Map id -> image path (from map-registry, injected by server). Used to show map image when selecting from dropdown. */
    let mapImagePaths = (function () {
      const el = document.getElementById('map-image-paths');
      if (el && el.textContent) try { return JSON.parse(el.textContent); } catch (e) {}
      return {};
    })();
    /** Mission IDs in IACP competitive rotation (mapId:variant). Injected by map-tool server from data/tournament-rotation.json. */
    const tournamentRotationMissionIds = (function () {
      const el = document.getElementById('tournament-rotation');
      if (el && el.textContent) try { return JSON.parse(el.textContent); } catch (e) {}
      return [];
    })();
    /** Full deployment zones { source, maps: { mapId: { red: [], blue: [] } } }. Injected by map-tool server. */
    let fullDeploymentZonesData = (function () {
      const el = document.getElementById('deployment-zones-data');
      if (el && el.textContent) try { return JSON.parse(el.textContent); } catch (e) {}
      return { source: 'extract-map-spaces.html', maps: {} };
    })();
    /** Current map's deployment zone coords (editable). Synced from fullDeploymentZonesData on map switch. */
    let deploymentZoneState = { red: [], blue: [] };
    /** Which zone to paint in Deployment zone mode: 'red' | 'blue' | 'clear'. */
    let deploymentZonePaint = 'red';
    /** Ensure path points to images/maps/ so map images load from the maps subfolder. */
    function mapImagePathForUrl(path) {
      if (!path) return path;
      if (path.includes('vassal_extracted/images/') && !path.includes('/maps/'))
        return path.replace('vassal_extracted/images/', 'vassal_extracted/images/maps/');
      return path;
    }
    /** All maps from map-registry (id + name) so dropdown is always populated. */
    const ALL_MAPS = [{"id":"30th-floor-plaza","name":"30th Floor Plaza"},{"id":"anchorhead-cantina-bar","name":"Anchorhead Cantina/Bar"},{"id":"bespin-tibanna-facility","name":"Bespin Tibanna Facility"},{"id":"chopper-base-atollon","name":"Chopper Base, Atollon"},{"id":"climate-research-camp","name":"Climate Research Camp"},{"id":"corellian-underground","name":"Corellian Underground"},{"id":"coruscant-back-alleys","name":"Coruscant Back Alleys"},{"id":"coruscant-landfill","name":"Coruscant Landfill"},{"id":"coruscant-senate-office","name":"Coruscant Senate Office"},{"id":"devaron-garrison","name":"Devaron Garrison"},{"id":"development-facility","name":"Development Facility"},{"id":"the-dune-sea","name":"The Dune Sea"},{"id":"echo-base","name":"Echo Base"},{"id":"endor-defense-station","name":"Endor Defense Station"},{"id":"endor-wilderness","name":"Endor Wilderness"},{"id":"geonosis-foundry","name":"Geonosis Foundry"},{"id":"hangar-bay","name":"Hangar Bay"},{"id":"hoth-battle-station","name":"Hoth Battle Station"},{"id":"hoth-weather-shelter","name":"Hoth Weather Shelter"},{"id":"imperial-command-hub","name":"Imperial Command Hub"},{"id":"imperial-labor-camp","name":"Imperial Labor Camp"},{"id":"imperial-research-lab","name":"Imperial Research Lab"},{"id":"imperial-space-station","name":"Imperial Space Station"},{"id":"imperial-tower","name":"Imperial Tower"},{"id":"isb-headquarters","name":"ISB Headquarters"},{"id":"isb-training-grounds","name":"ISB Training Grounds"},{"id":"jabba-s-palace","name":"Jabba's Palace"},{"id":"kashyyyk-station","name":"Kashyyyk Station"},{"id":"kuat-space-station","name":"Kuat Space Station"},{"id":"lothal-battlefront","name":"Lothal Battlefront"},{"id":"lothal-safehouse","name":"Lothal Safehouse"},{"id":"lothal-spaceport","name":"Lothal Spaceport"},{"id":"lothal-wastes","name":"Lothal Wastes"},{"id":"massassi-ruins","name":"Massassi Ruins"},{"id":"moisture-farm","name":"Moisture Farm"},{"id":"mos-eisley-back-alleys","name":"Mos Eisley Back Alleys"},{"id":"mos-eisley-cantina","name":"Mos Eisley Cantina"},{"id":"mos-eisley-outskirts","name":"Mos Eisley Outskirts"},{"id":"nal-hutta-swamps","name":"Nal Hutta Swamps"},{"id":"nelvaanian-war-zone","name":"Nelvaanian War Zone"},{"id":"ord-mantell-junkyard","name":"Ord Mantell Junkyard"},{"id":"the-pit-of-carkoon","name":"The Pit of Carkoon"},{"id":"sewers-of-nar-shaddaa","name":"Sewers of Nar Shaddaa"},{"id":"tarkin-initiative-labs","name":"Tarkin Initiative Labs"},{"id":"training-ground","name":"Training Ground"},{"id":"tython-meditation-field","name":"Tython Meditation Field"},{"id":"uscru-entertainment-district","name":"Uscru Entertainment District"},{"id":"wasskah-hunting-ground","name":"Wasskah Hunting Ground"},{"id":"wasteland-outpost","name":"Wasteland Outpost"},{"id":"b-omarr-subterranean-passageways-3-player","name":"* B'Omarr Subterranean Passageways (3-player)"},{"id":"scarif-imperial-hotel-3-player","name":"* Scarif Imperial Hotel (3-player)"},{"id":"hoth-battlefield-4-player","name":"* Hoth Battlefield (4-player)"},{"id":"nal-hutta-borderlands-4-player","name":"* Nal Hutta Borderlands (4-player)"},{"id":"temple-gardens-4-player","name":"* Temple Gardens (4-player)"}];

    function colToLetter(c) { return c < 26 ? String.fromCharCode(65 + c) : colToLetter(Math.floor(c/26)-1) + colToLetter(c%26); }
    function coordKey(col, row) { return colToLetter(col).toLowerCase() + (row + 1); }
    function edgeKey(a, b) { return [a, b].sort().join('|'); }
    /** Parse "a1", "t22" etc. to [col, row]. */
    function coordToColRow(coord) {
      const s = String(coord).toLowerCase();
      const match = s.match(/^([a-z]+)(\d+)$/);
      if (!match) return null;
      let col = 0;
      for (let i = 0; i < match[1].length; i++) col = 26 * col + (match[1].charCodeAt(i) - 97);
      const row = parseInt(match[2], 10) - 1;
      return [col, row];
    }

    function syncDeploymentZoneState(mapId) {
      const z = fullDeploymentZonesData?.maps?.[mapId];
      deploymentZoneState.red = (z?.red || []).map(s => String(s).toLowerCase());
      deploymentZoneState.blue = (z?.blue || []).map(s => String(s).toLowerCase());
    }

    /** Switch to editing the given map id: load its data from fullMapData if present, else empty. */
    function switchToMap(id) {
      syncDeploymentZoneState(id);
      const mapData = fullMapData?.maps?.[id];
      const name = ALL_MAPS.find(m => m.id === id)?.name || id;
      if (mapData) {
        loadMapIntoState(mapData);
        if (numCols === 0 && numRows === 0) initGridFromSpaces();
        document.getElementById('status').textContent = 'Editing: ' + name + ' (' + (mapData.spaces || []).length + ' spaces).';
      } else {
        state = { spaces: [], adjacency: {}, terrain: {}, blocking: [], impassableEdges: [], movementBlockingEdges: [], offMap: [], exterior: {} };
        numCols = 0;
        numRows = 0;
        overlay.width = 0;
        overlay.height = 0;
        overlay.style.width = '0px';
        overlay.style.height = '0px';
        document.getElementById('status').textContent = name + ' — Load map-spaces.json or Load map image to start.';
      }
    }

    function loadMapIntoState(mapData) {
      const loadedSpaces = new Set((mapData.spaces || []).map(s => String(s).toLowerCase()));
      state = {
        spaces: mapData.spaces || [],
        adjacency: mapData.adjacency || {},
        terrain: mapData.terrain || {},
        blocking: mapData.blocking || [],
        impassableEdges: mapData.impassableEdges || [],
        movementBlockingEdges: mapData.movementBlockingEdges || [],
        offMap: [],
        exterior: mapData.exterior || {}
      };
      if (numCols > 0 && numRows > 0) {
        const fullGrid = [];
        for (let r = 0; r < numRows; r++) for (let c = 0; c < numCols; c++) fullGrid.push(coordKey(c, r));
        state.offMap = fullGrid.filter(k => !loadedSpaces.has(k));
      }
      draw();
    }

    /** Build grid size and overlay from state.spaces when no image is loaded. */
    function initGridFromSpaces() {
      const positions = (state.spaces || []).map(c => coordToColRow(c)).filter(Boolean);
      if (positions.length === 0) return;
      const maxCol = Math.max(...positions.map(p => p[0]));
      const maxRow = Math.max(...positions.map(p => p[1]));
      numCols = maxCol + 1;
      numRows = maxRow + 1;
      const loadedSet = new Set((state.spaces || []).map(s => String(s).toLowerCase()));
      const fullGrid = [];
      for (let r = 0; r < numRows; r++) for (let c = 0; c < numCols; c++) fullGrid.push(coordKey(c, r));
      state.offMap = fullGrid.filter(k => !loadedSet.has(k));
      const totalW = x0 * 2 + numCols * dx;
      const totalH = y0 * 2 + numRows * dy;
      scale = Math.min(1, 1200 / totalW, 700 / totalH);
      const sw = Math.round(totalW * scale), sh = Math.round(totalH * scale);
      overlay.width = sw;
      overlay.height = sh;
      overlay.style.width = sw + 'px';
      overlay.style.height = sh + 'px';
      draw();
    }

    function init() {
      const w = img.naturalWidth, h = img.naturalHeight;
      if (!w || !h) { document.getElementById('status').textContent = 'Map image empty.'; return; }
      scale = Math.min(1, 1200 / w);
      const sw = Math.round(w * scale), sh = Math.round(h * scale);
      overlay.width = sw; overlay.height = sh;
      overlay.style.width = sw + 'px'; overlay.style.height = sh + 'px';
      numCols = Math.floor((sw - x0 * scale) / (dx * scale));
      numRows = Math.floor((sh - y0 * scale) / (dy * scale));
      if (state.spaces.length === 0) {
        for (let r = 0; r < numRows; r++) for (let c = 0; c < numCols; c++) {
          const k = coordKey(c, r);
          state.spaces.push(k);
          if (!state.terrain[k]) state.terrain[k] = 'normal';
          if (!state.adjacency[k]) {
            const n = [];
            if (c > 0) n.push(coordKey(c-1, r));
            if (c < numCols-1) n.push(coordKey(c+1, r));
            if (r > 0) n.push(coordKey(c, r-1));
            if (r < numRows-1) n.push(coordKey(c, r+1));
            state.adjacency[k] = n;
          }
        }
      }
      document.getElementById('status').textContent = 'Map loaded. Click cells (terrain) or edges (walls).';
      draw();
    }

    function draw() {
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      const sdx = dx * scale, sdy = dy * scale, sx0 = x0 * scale, sy0 = y0 * scale;
      const impSet = new Set(state.impassableEdges.map(e => edgeKey(e[0], e[1])));
      const dotSet = new Set((state.movementBlockingEdges || []).map(e => edgeKey(e[0], e[1])));
      const offSet = new Set((state.offMap || []).map(s => String(s).toLowerCase()));
      for (let r = 0; r < numRows; r++) for (let c = 0; c < numCols; c++) {
        const k = coordKey(c, r), x = sx0 + c * sdx, y = sy0 + r * sdy;
        if (offSet.has(k)) {
          ctx.fillStyle = 'rgba(80,80,80,0.75)';
          ctx.fillRect(x, y, sdx, sdy);
          if (deploymentZoneState.red.includes(k)) { ctx.fillStyle = 'rgba(220,53,69,0.55)'; ctx.fillRect(x, y, sdx, sdy); }
          else if (deploymentZoneState.blue.includes(k)) { ctx.fillStyle = 'rgba(13,110,253,0.55)'; ctx.fillRect(x, y, sdx, sdy); }
          ctx.strokeStyle = 'rgba(255,100,100,0.5)';
          ctx.strokeRect(x, y, sdx, sdy);
        } else {
          const ter = state.terrain[k] || 'normal';
          if (ter === 'difficult') { ctx.fillStyle = 'rgba(100,149,237,0.55)'; ctx.fillRect(x, y, sdx, sdy); }
          else if (ter === 'blocking') { ctx.fillStyle = 'rgba(220,53,69,0.65)'; ctx.fillRect(x, y, sdx, sdy); }
          if (state.exterior && state.exterior[k]) { ctx.fillStyle = 'rgba(50,205,50,0.5)'; ctx.fillRect(x, y, sdx, sdy); }
          if (deploymentZoneState.red.includes(k)) { ctx.fillStyle = 'rgba(220,53,69,0.5)'; ctx.fillRect(x, y, sdx, sdy); }
          else if (deploymentZoneState.blue.includes(k)) { ctx.fillStyle = 'rgba(13,110,253,0.5)'; ctx.fillRect(x, y, sdx, sdy); }
          ctx.strokeStyle = 'rgba(255,255,255,0.25)'; ctx.strokeRect(x, y, sdx, sdy);
        }
        for (const [dc, dr, dir] of [[0,-1,'n'],[1,0,'e'],[0,1,'s'],[-1,0,'w']]) {
          const nk = coordKey(c+dc, r+dr);
          const ek = edgeKey(k, nk);
          if (impSet.has(ek)) {
            ctx.fillStyle = 'rgba(255,255,0,0.8)';
            if (dir === 'n') ctx.fillRect(x, y, sdx, 5);
            else if (dir === 's') ctx.fillRect(x, y+sdy-5, sdx, 5);
            else if (dir === 'e') ctx.fillRect(x+sdx-5, y, 5, sdy);
            else ctx.fillRect(x, y, 5, sdy);
          } else if (dotSet.has(ek)) {
            ctx.fillStyle = 'rgba(255,100,100,0.7)';
            if (dir === 'n') ctx.fillRect(x, y, sdx, 4);
            else if (dir === 's') ctx.fillRect(x, y+sdy-4, sdx, 4);
            else if (dir === 'e') ctx.fillRect(x+sdx-4, y, 4, sdy);
            else ctx.fillRect(x, y, 4, sdy);
          }
        }
      }
    }

    function getCellInfo(e) {
      const r = overlay.getBoundingClientRect();
      const px = (e.clientX - r.left) * (overlay.width / r.width);
      const py = (e.clientY - r.top) * (overlay.height / r.height);
      const sdx = dx * scale, sdy = dy * scale, sx0 = x0 * scale, sy0 = y0 * scale;
      const col = Math.floor((px - sx0) / sdx), row = Math.floor((py - sy0) / sdy);
      if (col < 0 || row < 0 || col >= numCols || row >= numRows) return null;
      const lx = (px - sx0) % sdx, ly = (py - sy0) % sdy;
      const edge = (lx < 6 ? 'w' : lx > sdx - 6 ? 'e' : ly < 6 ? 'n' : ly > sdy - 6 ? 's' : null);
      return { col, row, edge, coord: coordKey(col, row) };
    }

    let dragState = null;

    function applyOffMap(info, paintOffMap) {
      const off = new Set((state.offMap || []).map(s => String(s).toLowerCase()));
      if (paintOffMap) off.add(info.coord);
      else off.delete(info.coord);
      state.offMap = [...off];
    }

    function applyExterior(info, paintExterior) {
      if (new Set((state.offMap || []).map(s => String(s).toLowerCase())).has(info.coord)) return;
      state.exterior = state.exterior || {};
      state.exterior[info.coord] = !!paintExterior;
    }

    function applyDeploymentZone(info, paint) {
      const k = String(info.coord).toLowerCase();
      deploymentZoneState.red = deploymentZoneState.red.filter(c => c !== k);
      deploymentZoneState.blue = deploymentZoneState.blue.filter(c => c !== k);
      if (paint === 'red') deploymentZoneState.red.push(k);
      else if (paint === 'blue') deploymentZoneState.blue.push(k);
    }

    function applyCellAction(info, mode, paintOffMap) {
      if (mode === 'offmap') {
        applyOffMap(info, paintOffMap);
      } else if (mode === 'exterior' && typeof paintOffMap === 'boolean') {
        applyExterior(info, paintOffMap);
      } else if (mode === 'terrain') {
        if (new Set((state.offMap || []).map(s => String(s).toLowerCase())).has(info.coord)) return;
        const next = { normal: 'difficult', difficult: 'blocking', blocking: 'normal' };
        state.terrain[info.coord] = next[state.terrain[info.coord] || 'normal'];
        state.blocking = state.spaces.filter(s => state.terrain[s] === 'blocking' && !(state.offMap || []).includes(s));
      } else if (mode === 'exterior') {
        if (new Set((state.offMap || []).map(s => String(s).toLowerCase())).has(info.coord)) return;
        state.exterior = state.exterior || {};
        state.exterior[info.coord] = !state.exterior[info.coord];
      } else if (mode === 'deploymentzone' && typeof paintOffMap === 'string') {
        applyDeploymentZone(info, paintOffMap);
      } else if (mode === 'edge' && info.edge) {
        const nc = info.edge === 'e' ? info.col + 1 : info.edge === 'w' ? info.col - 1 : info.col;
        const nr = info.edge === 's' ? info.row + 1 : info.edge === 'n' ? info.row - 1 : info.row;
        if (nc >= 0 && nc < numCols && nr >= 0 && nr < numRows) {
          const nk = coordKey(nc, nr);
          const ek = edgeKey(info.coord, nk);
          const impIdx = state.impassableEdges.findIndex(([a,b]) => edgeKey(a,b) === ek);
          const dotIdx = (state.movementBlockingEdges || []).findIndex(([a,b]) => edgeKey(a,b) === ek);
          const removeFromAdj = () => {
            state.adjacency[info.coord] = (state.adjacency[info.coord] || []).filter(x => x !== nk);
            state.adjacency[nk] = (state.adjacency[nk] || []).filter(x => x !== info.coord);
          };
          const addToAdj = () => {
            if (!(state.adjacency[info.coord] || []).includes(nk)) state.adjacency[info.coord].push(nk);
            if (!(state.adjacency[nk] || []).includes(info.coord)) state.adjacency[nk].push(info.coord);
          };
          if (impIdx >= 0) {
            state.impassableEdges.splice(impIdx, 1);
            state.movementBlockingEdges = state.movementBlockingEdges || [];
            state.movementBlockingEdges.push([info.coord, nk]);
            removeFromAdj();
          } else if (dotIdx >= 0) {
            state.movementBlockingEdges.splice(dotIdx, 1);
            addToAdj();
          } else {
            state.impassableEdges.push([info.coord, nk]);
            removeFromAdj();
          }
        }
      }
    }

    overlay.onmousedown = (e) => {
      if (e.button !== 0) return;
      e.preventDefault();
      const info = getCellInfo(e);
      if (!info) return;
      const mode = document.querySelector('input[name="mode"]:checked').value;
      if (mode === 'offmap') {
        const off = new Set((state.offMap || []).map(s => String(s).toLowerCase()));
        const paintOffMap = !off.has(info.coord);
        applyOffMap(info, paintOffMap);
        dragState = { mode, paintOffMap, lastCoord: info.coord };
        draw();
      } else if (mode === 'exterior') {
        const paintExterior = !(state.exterior && state.exterior[info.coord]);
        applyExterior(info, paintExterior);
        dragState = { mode, paintOffMap: paintExterior, lastCoord: info.coord };
        draw();
      } else if (mode === 'deploymentzone') {
        applyDeploymentZone(info, deploymentZonePaint);
        dragState = { mode, paintOffMap: deploymentZonePaint, lastCoord: info.coord };
        draw();
      } else {
        applyCellAction(info, mode, null);
        draw();
      }
    };

    overlay.onmousemove = (e) => {
      if (!dragState) return;
      const info = getCellInfo(e);
      if (!info || info.coord === dragState.lastCoord) return;
      dragState.lastCoord = info.coord;
      applyCellAction(info, dragState.mode, dragState.paintOffMap);
      draw();
    };

    overlay.onmouseup = overlay.onmouseleave = () => {
      if (dragState) { dragState = null; }
    };

    document.addEventListener('mouseup', () => { if (dragState) dragState = null; });

    function updateInRotationCheckbox() {
      const select = document.getElementById('mapSelect');
      const cb = document.getElementById('inRotationCheckbox');
      if (!select || !cb) return;
      const mapId = select.value || '';
      const inRotation = Array.isArray(tournamentRotationMissionIds) && tournamentRotationMissionIds.some(m => String(m).startsWith(mapId + ':'));
      cb.checked = !!inRotation;
    }

    // Populate map dropdown with every map on load
    (function initMapSelect() {
      const select = document.getElementById('mapSelect');
      ALL_MAPS.forEach(m => select.appendChild(new Option(m.name, m.id)));
      select.value = 'mos-eisley-outskirts';
      select.onchange = () => {
        const id = select.value;
        if (id) {
          const path = mapImagePathForUrl(mapImagePaths[id]);
          if (path) img.src = '/' + path;
          switchToMap(id);
          updateInRotationCheckbox();
        }
      };
      if (fullMapData && fullMapData.maps && Object.keys(fullMapData.maps).length) {
        const idToShow = fullMapData.maps[select.value] ? select.value : Object.keys(fullMapData.maps)[0];
        select.value = idToShow;
        const pathToShow = mapImagePathForUrl(mapImagePaths[idToShow]);
        if (pathToShow) img.src = '/' + pathToShow;
        switchToMap(idToShow);
      } else {
        const defaultPath = mapImagePathForUrl(mapImagePaths['mos-eisley-outskirts']);
        if (defaultPath) img.src = '/' + defaultPath;
        switchToMap('mos-eisley-outskirts');
      }
      updateInRotationCheckbox();
    })();

    function applyLoadedData(data) {
      fullMapData = data;
      const maps = data.maps || {};
      const mapIdsInFile = Object.keys(maps);
      const select = document.getElementById('mapSelect');
      const currentId = select.value;
      const idToShow = maps[currentId] ? currentId : (mapIdsInFile[0] || null);
      if (idToShow) {
        select.value = idToShow;
        switchToMap(idToShow);
        const n = mapIdsInFile.length;
        document.getElementById('status').textContent = 'Loaded ' + n + ' map(s). Editing: ' + (ALL_MAPS.find(m => m.id === idToShow)?.name || idToShow) + '.';
      } else {
        document.getElementById('status').textContent = 'File has no map data. Expected { "maps": { "map-id": { "spaces": [...] } } }.';
      }
    }

    // Auto-load data/map-spaces.json when opened from a static server (if not already injected)
    if (!fullMapData || !fullMapData.maps) {
      fetch('../../data/map-spaces.json').then(r => r.ok ? r.json() : Promise.reject()).then(applyLoadedData).catch(() => {});
    }

    function doSave() {
      const offSet = new Set((state.offMap || []).map(s => String(s).toLowerCase()));
      const onMapSpaces = state.spaces.filter(s => !offSet.has(String(s).toLowerCase()));
      const onMapSet = new Set(onMapSpaces.map(s => String(s).toLowerCase()));
      const adj = {};
      for (const coord of onMapSpaces) {
        const k = String(coord).toLowerCase();
        adj[k] = (state.adjacency[k] || []).filter(n => onMapSet.has(String(n).toLowerCase()));
      }
      const terrain = {};
      for (const k of onMapSpaces) {
        const t = state.terrain[String(k).toLowerCase()];
        if (t && t !== 'normal') terrain[String(k).toLowerCase()] = t;
      }
      const blocking = onMapSpaces.filter(s => state.terrain[String(s).toLowerCase()] === 'blocking');
      const impEdges = (state.impassableEdges || []).filter(([a,b]) => onMapSet.has(String(a).toLowerCase()) && onMapSet.has(String(b).toLowerCase()));
      const movEdges = (state.movementBlockingEdges || []).filter(([a,b]) => onMapSet.has(String(a).toLowerCase()) && onMapSet.has(String(b).toLowerCase()));
      const exterior = {};
      for (const k of onMapSpaces) {
        const key = String(k).toLowerCase();
        if (state.exterior && state.exterior[key]) exterior[key] = true;
      }
      const exportState = { spaces: onMapSpaces, adjacency: adj, terrain, blocking, impassableEdges: impEdges, movementBlockingEdges: movEdges, exterior: Object.keys(exterior).length ? exterior : undefined };
      const selectedId = document.getElementById('mapSelect').value || 'mos-eisley-outskirts';
      const data = fullMapData && fullMapData.maps
        ? { ...fullMapData, maps: { ...fullMapData.maps, [selectedId]: exportState } }
        : { source: 'extract-map-spaces.html', maps: { [selectedId]: exportState } };
      const saveUrl = (typeof location !== 'undefined' && location.origin) ? (location.origin + '/save-map-spaces') : '/save-map-spaces';
      fetch(saveUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      }).then((r) => {
        if (r.ok) {
          document.getElementById('status').textContent = 'Saved to data/map-spaces.json (' + onMapSpaces.length + ' spaces for ' + selectedId + ').';
          if (typeof fullMapData === 'object') fullMapData = data;
        } else return r.text().then((t) => Promise.reject(new Error(t || r.status)));
      }).catch((err) => {
        document.getElementById('status').textContent = 'Save failed (run map-tool server?): ' + (err.message || 'unknown');
      });
    }

    document.getElementById('saveBtn').onclick = () => doSave();

    function doSaveZones() {
      const selectedId = document.getElementById('mapSelect').value || 'mos-eisley-outskirts';
      const maps = { ...(fullDeploymentZonesData?.maps || {}), [selectedId]: { red: [...deploymentZoneState.red], blue: [...deploymentZoneState.blue] } };
      const data = { source: fullDeploymentZonesData?.source || 'extract-map-spaces.html', maps };
      const saveUrl = (typeof location !== 'undefined' && location.origin) ? (location.origin + '/save-deployment-zones') : '/save-deployment-zones';
      fetch(saveUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      }).then((r) => {
        if (r.ok) {
          fullDeploymentZonesData = data;
          document.getElementById('status').textContent = 'Saved to data/deployment-zones.json (' + deploymentZoneState.red.length + ' red, ' + deploymentZoneState.blue.length + ' blue for ' + selectedId + ').';
        } else return r.text().then((t) => Promise.reject(new Error(t || r.status)));
      }).catch((err) => {
        document.getElementById('status').textContent = 'Save zones failed (run map-tool server?): ' + (err.message || 'unknown');
      });
    }
    document.getElementById('saveZonesBtn').onclick = () => doSaveZones();

    document.getElementById('zonePaintRed').onclick = () => { deploymentZonePaint = 'red'; };
    document.getElementById('zonePaintBlue').onclick = () => { deploymentZonePaint = 'blue'; };
    document.getElementById('zonePaintClear').onclick = () => { deploymentZonePaint = 'clear'; };

    img.onload = init;
    img.onerror = () => {
      document.getElementById('status').textContent = 'Select a map above; grid appears when data is loaded.';
    };
    if (img.complete) init();
  </script>
</body>
</html>
